/*
 * kernel/drivers/media/video/tegra
 *
 * Aptina MT9D115 sensor driver
 *
 * Copyright (C) 2010 NVIDIA Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <media/yuv_sensor.h>

#define _CAM_SENSOR_DETECT_
#ifdef _CAM_SENSOR_DETECT_
#include <linux/regulator/consumer.h>
#include <linux/err.h>
#include <linux/clk.h>
#include <mach/clk.h>
#include <mach/board-ventana-misc.h>
#endif
#define SENSOR_WIDTH_REG 0x2703
#define SENSOR_1280_WIDTH_VAL 0x0518
#define MI5140_SENSOR_NAME "mi5140"
#define ONE_TIME_TABLE_CHECK_REG 0x8016
#define ONE_TIME_TABLE_CHECK_DATA 0x086C

struct sensor_reg {
	u16 addr;
	u16 val;
};

#define SEQUENCE_WAIT_MS  SENSOR_WAIT_MS
#define SEQUENCE_END      SENSOR_TABLE_END
#define SENSOR_BYTE_WRITE    (SEQUENCE_END+1)
#define SENSOR_WORD_WRITE    (SEQUENCE_END+2)
#define SENSOR_MASK_BYTE_WRITE  (SEQUENCE_END+3)
#define SENSOR_MASK_WORD_WRITE  (SEQUENCE_END+4)


struct sensor_reg_ex {
  u16 cmd;
	u16 addr;
	u16 val;
};

struct sensor_info {
	int mode;
	struct i2c_client *i2c_client;
	struct yuv_sensor_platform_data *pdata;
#ifdef _CAM_SENSOR_DETECT_
	struct device dev;
#endif
};

static struct sensor_info *info;
static int g_initialized=0;

static struct sensor_reg_ex mode_1280x960_rev1[] =
{
//; Rev1:
//; Release date: Feb-23-2011
//; Rev2:
//; Release date: Mar-09-2011
//;**********************************************************************************************************
//; [Section1]
//;**********************************************************************************************************
//for DevWare used only
//XMCLK=24000000
//STATE=Sensor Reset, 1
//delay=10
//STATE=Sensor Reset, 0

//;**********************************************************************************************************
//;[Section2]		// PLL and Timing settings
//;**********************************************************************************************************

//;; [PLL setting]

//;[PLL_24]
// for 24 MHz input, VCO=720 MHz
//
{SENSOR_WORD_WRITE, 0x0010, 0x033C} ,  //PLL Dividers = 828
{SENSOR_WORD_WRITE, 0x0012, 0x0070} , 	// PLL_P_DIVIDERS
{SENSOR_WORD_WRITE, 0x0014, 0x2025} , 	// PLL_CONTROL
{SENSOR_WORD_WRITE, 0x0022, 0x01E0} , 	// VDD_DIS_COUNTER -- 2us
{SENSOR_WORD_WRITE, 0x002A, 0x7F7B} , 	// PLL_P4_P5_P6_DIVIDERS
{SENSOR_WORD_WRITE, 0x002C, 0x0000} , 	// PLL_P7_DIVIDER
{SENSOR_WORD_WRITE, 0x002E, 0x0000} , 	// SENSOR_CLOCK_DIVIDER

{SENSOR_WORD_WRITE,  0x001E, 0x0777} , 	// PAD_SLEW_PAD_CONFIG
{SENSOR_WORD_WRITE,  0x0018, 0x400C} , 	// STANDBY_CONTROL_AND_STATUS, release device from standby
// wait for power-up-stop status
{SENSOR_WAIT_MS,0,30}, //DELAY= 30

{SENSOR_WORD_WRITE,  0x098E, 0x6004} , 	// LOGICAL_ADDRESS_ACCESS [IO_I2C_CLK_DIVIDER]
{SENSOR_WORD_WRITE, 0xE004, 0x0708} ,  //I2C Master Clock Divider = 1800
{SENSOR_WORD_WRITE,  0xE002, 0x0108} , 	// IO_ALGO
{SENSOR_WAIT_MS,0,30}, //DELAY= 30

// resync I2C master
{SENSOR_WORD_WRITE,  0x0016, 0x0057} , 	// CLOCKS_CONTROL
{SENSOR_WORD_WRITE,  0x3B00, 0x80A0} , 	// TXBUFFER_DATA_REGISTER_0
{SENSOR_WORD_WRITE,  0x3B02, 0x0000} , 	// TXBUFFER_DATA_REGISTER_1
{SENSOR_WORD_WRITE,  0x3B86, 0x0002} , 	// TXBUFFER_TOTAL_BYTE_COUNT
{SENSOR_WORD_WRITE,  0x3B82, 0x0007} , 	// I2C_MASTER_CONTROL
{SENSOR_WAIT_MS,0,30}, //DELAY= 30
{SENSOR_WORD_WRITE,  0x0016, 0x0047} , 	// CLOCKS_CONTROL

//;[timing]
{SENSOR_WORD_WRITE, 0x098E, 0x1000} ,
{SENSOR_WORD_WRITE, 0xC86C, 0x0518} ,	//Output Width (A) = 1304
{SENSOR_WORD_WRITE, 0xC86E, 0x03D4} ,	//Output Height (A) = 980
{SENSOR_WORD_WRITE, 0xC83A, 0x000C} ,	//Row Start (A) = 12
{SENSOR_WORD_WRITE, 0xC83C, 0x0018} ,	//Column Start (A) = 24
{SENSOR_WORD_WRITE, 0xC83E, 0x07B1} ,	//Row End (A) = 1969
{SENSOR_WORD_WRITE, 0xC840, 0x0A45} ,	//Column End (A) = 2629
{SENSOR_WORD_WRITE, 0xC842, 0x0001} ,	//Row Speed (A) = 1
{SENSOR_WORD_WRITE, 0xC844, 0x0103} ,	//Core Skip X (A) = 259
{SENSOR_WORD_WRITE, 0xC846, 0x0103} ,	//Core Skip Y (A) = 259
{SENSOR_WORD_WRITE, 0xC848, 0x0103} ,	//Pipe Skip X (A) = 259
{SENSOR_WORD_WRITE, 0xC84A, 0x0103} ,	//Pipe Skip Y (A) = 259
{SENSOR_WORD_WRITE, 0xC84C, 0x00F6} ,	//Power Mode (A) = 246
{SENSOR_WORD_WRITE, 0xC84E, 0x0001} ,	//Bin Mode (A) = 1
{SENSOR_BYTE_WRITE, 0xC850, 0x00} ,	//Orientation (A) = 0
{SENSOR_BYTE_WRITE, 0xC851, 0x00} ,	//Pixel Order (A) = 0
{SENSOR_WORD_WRITE, 0xC852, 0x019C} ,	//Fine Correction (A) = 412
{SENSOR_WORD_WRITE, 0xC854, 0x0732} ,	//Fine IT Min (A) = 1842
{SENSOR_WORD_WRITE, 0xC856, 0x048E} ,	//Fine IT Max Margin (A) = 1166
{SENSOR_WORD_WRITE, 0xC858, 0x0002} ,	//Coarse IT Min (A) = 2
{SENSOR_WORD_WRITE, 0xC85A, 0x0001} ,	//Coarse IT Max Margin (A) = 1
{SENSOR_WORD_WRITE, 0xC85C, 0x0423} ,	//Min Frame Lines (A) = 1059
{SENSOR_WORD_WRITE, 0xC85E, 0xFFFF} ,	//Max Frame Lines (A) = 65535
{SENSOR_WORD_WRITE, 0xC860, 0x0423} ,	//Base Frame Lines (A) = 1059
{SENSOR_WORD_WRITE, 0xC862, 0x1018} ,  //Min Line Length (A) = 4120
{SENSOR_WORD_WRITE, 0xC864, 0xFFFE} ,	//Max Line Length (A) = 65534
{SENSOR_WORD_WRITE, 0xC866, 0x7F7B} ,  //P456 Divider (A) = 32635
{SENSOR_WORD_WRITE, 0xC868, 0x0423} ,	//Frame Lines (A) = 1059
{SENSOR_WORD_WRITE, 0xC86A, 0x1018} ,  //Line Length (A) = 4120
{SENSOR_WORD_WRITE, 0xC870, 0x0014} ,	//RX FIFO Watermark (A) = 20
{SENSOR_WORD_WRITE, 0xC8AA, 0x0500} ,	//Output_0 Image Width = 1280
{SENSOR_WORD_WRITE, 0xC8AC, 0x03C0} ,	//Output_0 Image Height = 960
{SENSOR_WORD_WRITE, 0xC8AE, 0x0001} ,	//Output_0 Image Format = 1
{SENSOR_WORD_WRITE, 0xC8B0, 0x0000} ,	//Output_0 Format Order = 0
{SENSOR_WORD_WRITE, 0xC8B8, 0x0004} ,	//Output_0 JPEG control = 4
{SENSOR_WORD_WRITE, 0xC8A4, 0x0A28} ,	//Output Width (B) = 2600
{SENSOR_WORD_WRITE, 0xC8A6, 0x07A0} ,	//Output Height (B) = 1952
{SENSOR_WORD_WRITE, 0xC872, 0x0010} ,	//Row Start (B) = 16
{SENSOR_WORD_WRITE, 0xC874, 0x001C} ,	//Column Start (B) = 28
{SENSOR_WORD_WRITE, 0xC876, 0x07AF} ,	//Row End (B) = 1967
{SENSOR_WORD_WRITE, 0xC878, 0x0A43} ,	//Column End (B) = 2627
{SENSOR_WORD_WRITE, 0xC87A, 0x0001} ,	//Row Speed (B) = 1
{SENSOR_WORD_WRITE, 0xC87C, 0x0101} ,	//Core Skip X (B) = 257
{SENSOR_WORD_WRITE, 0xC87E, 0x0101} ,	//Core Skip Y (B) = 257
{SENSOR_WORD_WRITE, 0xC880, 0x0101} ,	//Pipe Skip X (B) = 257
{SENSOR_WORD_WRITE, 0xC882, 0x0101} ,	//Pipe Skip Y (B) = 257
{SENSOR_WORD_WRITE, 0xC884, 0x00F2} ,	//Power Mode (B) = 242
{SENSOR_WORD_WRITE, 0xC886, 0x0000} ,	//Bin Mode (B) = 0
{SENSOR_BYTE_WRITE, 0xC888, 0x00} ,	//Orientation (B) = 0
{SENSOR_BYTE_WRITE, 0xC889, 0x00} ,	//Pixel Order (B) = 0
{SENSOR_WORD_WRITE, 0xC88A, 0x009C} ,	//Fine Correction (B) = 156
{SENSOR_WORD_WRITE, 0xC88C, 0x034A} ,	//Fine IT Min (B) = 842
{SENSOR_WORD_WRITE, 0xC88E, 0x02A6} ,	//Fine IT Max Margin (B) = 678
{SENSOR_WORD_WRITE, 0xC890, 0x0002} ,	//Coarse IT Min (B) = 2
{SENSOR_WORD_WRITE, 0xC892, 0x0001} ,	//Coarse IT Max Margin (B) = 1
{SENSOR_WORD_WRITE, 0xC894, 0x07EF} ,	//Min Frame Lines (B) = 2031
{SENSOR_WORD_WRITE, 0xC896, 0xFFFF} ,	//Max Frame Lines (B) = 65535
{SENSOR_WORD_WRITE, 0xC898, 0x07EF} ,	//Base Frame Lines (B) = 2031
{SENSOR_WORD_WRITE, 0xC89A, 0x2469} ,	//Min Line Length (B) = 7947
{SENSOR_WORD_WRITE, 0xC89C, 0xFFFE} ,	//Max Line Length (B) = 65534
{SENSOR_WORD_WRITE, 0xC89E, 0x7F7B} ,	//P456 Divider (B) = 32636
{SENSOR_WORD_WRITE, 0xC8A0, 0x07EF} ,	//Frame Lines (B) = 2031
{SENSOR_WORD_WRITE, 0xC8A2, 0x2469} ,	//Line Length (B) = 7947
{SENSOR_WORD_WRITE, 0xC8A8, 0x0014} ,	//RX FIFO Watermark (B) = 20
{SENSOR_WORD_WRITE, 0xC8C0, 0x0A20} ,	//Output_1 Image Width = 2592
{SENSOR_WORD_WRITE, 0xC8C2, 0x0798} ,	//Output_1 Image Height = 1944
{SENSOR_WORD_WRITE, 0xC8C4, 0x0001} ,	//Output_1 Image Format = 1
{SENSOR_WORD_WRITE, 0xC8C6, 0x0000} ,	//Output_1 Format Order = 0
{SENSOR_WORD_WRITE, 0xC8CE, 0x0004} ,	//Output_1 JPEG control = 4
{SENSOR_WORD_WRITE, 0xA010, 0x0119} ,	//fd_min_expected50hz_flicker_period = 308
{SENSOR_WORD_WRITE, 0xA012, 0x012D} ,	//fd_max_expected50hz_flicker_period = 328
{SENSOR_WORD_WRITE, 0xA014, 0x00E9} ,	//fd_min_expected60hz_flicker_period = 255
{SENSOR_WORD_WRITE, 0xA016, 0x00FD} ,	//fd_max_expected60hz_flicker_period = 275
{SENSOR_WORD_WRITE, 0xA018, 0x0123} ,	//fd_expected50hz_flicker_period (A) = 318
{SENSOR_WORD_WRITE, 0xA01A, 0x0081} ,	//fd_expected50hz_flicker_period (B) = 149
{SENSOR_WORD_WRITE, 0xA01C, 0x00F3} ,	//fd_expected60hz_flicker_period (A) = 265
{SENSOR_WORD_WRITE, 0xA01E, 0x006B} ,	//fd_expected60hz_flicker_period (B) = 124
{SENSOR_BYTE_WRITE, 0xDC0A, 0x06} ,	//Scaler Allow Zoom Ratio = 6
{SENSOR_WORD_WRITE, 0xDC1C, 0x2710} ,	//System Zoom Ratio = 10000
//{SENSOR_WORD_WRITE, 0xE004, 0x1E00} ,	//I2C Master Clock Divider = 7680
{SENSOR_BYTE_WRITE, 0x8404, 0x06} ,	//Refresh Sequencer Mode = 6
{SENSOR_WAIT_MS,0,100}, //DELAY= 100


//;**********************************************************************************************************
//; [Section3]	} ,	// Firmware patch and char settings
//;**********************************************************************************************************

//;[k28a_rev3_FW_patch]
//  k28a_rev03_patch01_basic_REV5
{SENSOR_WORD_WRITE,  0x0982, 0x0000} ,  	// ACCESS_CTL_STAT
{SENSOR_WORD_WRITE,  0x098A, 0x0000} ,  	// PHYSICAL_ADDRESS_ACCESS
// McNex patch
{SENSOR_WORD_WRITE,  0x886C, 0xC0F1} ,
{SENSOR_WORD_WRITE,  0x886E, 0xC5E1} ,
{SENSOR_WORD_WRITE,  0x8870, 0x246A} ,
{SENSOR_WORD_WRITE,  0x8872, 0x1280} ,
{SENSOR_WORD_WRITE,  0x8874, 0xC4E1} ,
{SENSOR_WORD_WRITE,  0x8876, 0xD20F} ,
{SENSOR_WORD_WRITE,  0x8878, 0x2069} ,
{SENSOR_WORD_WRITE,  0x887A, 0x0000} ,
{SENSOR_WORD_WRITE,  0x887C, 0x6A62} ,
{SENSOR_WORD_WRITE,  0x887E, 0x1303} ,
{SENSOR_WORD_WRITE,  0x8880, 0x0084} ,
{SENSOR_WORD_WRITE,  0x8882, 0x1734} ,
{SENSOR_WORD_WRITE,  0x8884, 0x7005} ,
{SENSOR_WORD_WRITE,  0x8886, 0xD801} ,
{SENSOR_WORD_WRITE,  0x8888, 0x8A41} ,
{SENSOR_WORD_WRITE,  0x888A, 0xD900} ,
{SENSOR_WORD_WRITE,  0x888C, 0x0D5A} ,
{SENSOR_WORD_WRITE,  0x888E, 0x0664} ,
{SENSOR_WORD_WRITE,  0x8890, 0x8B61} ,
{SENSOR_WORD_WRITE,  0x8892, 0xE80B} ,
{SENSOR_WORD_WRITE,  0x8894, 0x000D} ,
{SENSOR_WORD_WRITE,  0x8896, 0x0020} ,
{SENSOR_WORD_WRITE,  0x8898, 0xD508} ,
{SENSOR_WORD_WRITE,  0x889A, 0x1504} ,
{SENSOR_WORD_WRITE,  0x889C, 0x1400} ,
{SENSOR_WORD_WRITE,  0x889E, 0x7840} ,
{SENSOR_WORD_WRITE,  0x88A0, 0xD007} ,
{SENSOR_WORD_WRITE,  0x88A2, 0x0DFB} ,
{SENSOR_WORD_WRITE,  0x88A4, 0x9004} ,
{SENSOR_WORD_WRITE,  0x88A6, 0xC4C1} ,
{SENSOR_WORD_WRITE,  0x88A8, 0x2029} ,
{SENSOR_WORD_WRITE,  0x88AA, 0x0300} ,
{SENSOR_WORD_WRITE,  0x88AC, 0x0219} ,
{SENSOR_WORD_WRITE,  0x88AE, 0x06C4} ,
{SENSOR_WORD_WRITE,  0x88B0, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x88B2, 0x08C8} ,
{SENSOR_WORD_WRITE,  0x88B4, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x88B6, 0x086C} ,
{SENSOR_WORD_WRITE,  0x88B8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x88BA, 0x08C0} ,
{SENSOR_WORD_WRITE,  0x88BC, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x88BE, 0x08C8} ,
{SENSOR_WORD_WRITE,  0x88C0, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x88C2, 0x0C98} ,
{SENSOR_WORD_WRITE,  0x88C4, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x88C6, 0x0AF8} ,
{SENSOR_WORD_WRITE,  0x88C8, 0x0005} ,
{SENSOR_WORD_WRITE,  0x88CA, 0x0004} ,
{SENSOR_WORD_WRITE,  0x88CC, 0x0000} ,
{SENSOR_WORD_WRITE,  0x88CE, 0x0000} ,
{SENSOR_WORD_WRITE,  0x88D0, 0xD1B4} ,
{SENSOR_WORD_WRITE,  0x88D2, 0xD2B5} ,
{SENSOR_WORD_WRITE,  0x88D4, 0x11B2} ,
{SENSOR_WORD_WRITE,  0x88D6, 0x8903} ,
{SENSOR_WORD_WRITE,  0x88D8, 0x1252} ,
{SENSOR_WORD_WRITE,  0x88DA, 0x0100} ,
{SENSOR_WORD_WRITE,  0x88DC, 0x7B6F} ,
{SENSOR_WORD_WRITE,  0x88DE, 0xB808} ,
{SENSOR_WORD_WRITE,  0x88E0, 0x2004} ,
{SENSOR_WORD_WRITE,  0x88E2, 0x0F80} ,
{SENSOR_WORD_WRITE,  0x88E4, 0x0000} ,
{SENSOR_WORD_WRITE,  0x88E6, 0xFF00} ,
{SENSOR_WORD_WRITE,  0x88E8, 0x7865} ,
{SENSOR_WORD_WRITE,  0x88EA, 0x19B2} ,
{SENSOR_WORD_WRITE,  0x88EC, 0x8024} ,
{SENSOR_WORD_WRITE,  0x88EE, 0xD0AF} ,
{SENSOR_WORD_WRITE,  0x88F0, 0x8801} ,
{SENSOR_WORD_WRITE,  0x88F2, 0xB8E1} ,
{SENSOR_WORD_WRITE,  0x88F4, 0xD800} ,
{SENSOR_WORD_WRITE,  0x88F6, 0xF404} ,
{SENSOR_WORD_WRITE,  0x88F8, 0x1234} ,
{SENSOR_WORD_WRITE,  0x88FA, 0x0080} ,
{SENSOR_WORD_WRITE,  0x88FC, 0x1955} ,
{SENSOR_WORD_WRITE,  0x88FE, 0x803C} ,
{SENSOR_WORD_WRITE,  0x8900, 0x1233} ,
{SENSOR_WORD_WRITE,  0x8902, 0x0080} ,
{SENSOR_WORD_WRITE,  0x8904, 0xB802} ,
{SENSOR_WORD_WRITE,  0x8906, 0x1957} ,
{SENSOR_WORD_WRITE,  0x8908, 0x803C} ,
{SENSOR_WORD_WRITE,  0x890A, 0x1958} ,
{SENSOR_WORD_WRITE,  0x890C, 0x803C} ,
{SENSOR_WORD_WRITE,  0x890E, 0x1959} ,
{SENSOR_WORD_WRITE,  0x8910, 0x803C} ,
{SENSOR_WORD_WRITE,  0x8912, 0x195A} ,
{SENSOR_WORD_WRITE,  0x8914, 0x803C} ,
{SENSOR_WORD_WRITE,  0x8916, 0x7EE0} ,
{SENSOR_WORD_WRITE,  0x8918, 0xC0F1} ,
{SENSOR_WORD_WRITE,  0x891A, 0x0936} ,
{SENSOR_WORD_WRITE,  0x891C, 0x06C4} ,
{SENSOR_WORD_WRITE,  0x891E, 0xD5A4} ,
{SENSOR_WORD_WRITE,  0x8920, 0x8D2C} ,
{SENSOR_WORD_WRITE,  0x8922, 0x0983} ,
{SENSOR_WORD_WRITE,  0x8924, 0x0010} ,
{SENSOR_WORD_WRITE,  0x8926, 0xD2A1} ,
{SENSOR_WORD_WRITE,  0x8928, 0x123A} ,
{SENSOR_WORD_WRITE,  0x892A, 0x0083} ,
{SENSOR_WORD_WRITE,  0x892C, 0x123B} ,
{SENSOR_WORD_WRITE,  0x892E, 0x008F} ,
{SENSOR_WORD_WRITE,  0x8930, 0x8D55} ,
{SENSOR_WORD_WRITE,  0x8932, 0xBB08} ,
{SENSOR_WORD_WRITE,  0x8934, 0x7BE5} ,
{SENSOR_WORD_WRITE,  0x8936, 0x8DF6} ,
{SENSOR_WORD_WRITE,  0x8938, 0xBA08} ,
{SENSOR_WORD_WRITE,  0x893A, 0x7AE5} ,
{SENSOR_WORD_WRITE,  0x893C, 0x0B0D} ,
{SENSOR_WORD_WRITE,  0x893E, 0x00A3} ,
{SENSOR_WORD_WRITE,  0x8940, 0x8DC5} ,
{SENSOR_WORD_WRITE,  0x8942, 0x8D54} ,
{SENSOR_WORD_WRITE,  0x8944, 0xAD45} ,
{SENSOR_WORD_WRITE,  0x8946, 0xF026} ,
{SENSOR_WORD_WRITE,  0x8948, 0x65DB} ,
{SENSOR_WORD_WRITE,  0x894A, 0x8B6D} ,
{SENSOR_WORD_WRITE,  0x894C, 0x0815} ,
{SENSOR_WORD_WRITE,  0x894E, 0x00E2} ,
{SENSOR_WORD_WRITE,  0x8950, 0x65DA} ,
{SENSOR_WORD_WRITE,  0x8952, 0x8A51} ,
{SENSOR_WORD_WRITE,  0x8954, 0x0A0D} ,
{SENSOR_WORD_WRITE,  0x8956, 0x0002} ,
{SENSOR_WORD_WRITE,  0x8958, 0xE683} ,
{SENSOR_WORD_WRITE,  0x895A, 0x22CA} ,
{SENSOR_WORD_WRITE,  0x895C, 0x038B} ,
{SENSOR_WORD_WRITE,  0x895E, 0xF69A} ,
{SENSOR_WORD_WRITE,  0x8960, 0xDA00} ,
{SENSOR_WORD_WRITE,  0x8962, 0xAD45} ,
{SENSOR_WORD_WRITE,  0x8964, 0x2540} ,
{SENSOR_WORD_WRITE,  0x8966, 0x1343} ,
{SENSOR_WORD_WRITE,  0x8968, 0xE180} ,
{SENSOR_WORD_WRITE,  0x896A, 0x2540} ,
{SENSOR_WORD_WRITE,  0x896C, 0x144F} ,
{SENSOR_WORD_WRITE,  0x896E, 0xF6D2} ,
{SENSOR_WORD_WRITE,  0x8970, 0x719F} ,
{SENSOR_WORD_WRITE,  0x8972, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x8974, 0x20A8} ,
{SENSOR_WORD_WRITE,  0x8976, 0x0280} ,
{SENSOR_WORD_WRITE,  0x8978, 0x8B20} ,
{SENSOR_WORD_WRITE,  0x897A, 0x0813} ,
{SENSOR_WORD_WRITE,  0x897C, 0x0043} ,
{SENSOR_WORD_WRITE,  0x897E, 0xE201} ,
{SENSOR_WORD_WRITE,  0x8980, 0x7A4F} ,
{SENSOR_WORD_WRITE,  0x8982, 0xAD45} ,
{SENSOR_WORD_WRITE,  0x8984, 0xE301} ,
{SENSOR_WORD_WRITE,  0x8986, 0xE701} ,
{SENSOR_WORD_WRITE,  0x8988, 0xF004} ,
{SENSOR_WORD_WRITE,  0x898A, 0x8F20} ,
{SENSOR_WORD_WRITE,  0x898C, 0x09F3} ,
{SENSOR_WORD_WRITE,  0x898E, 0x8002} ,
{SENSOR_WORD_WRITE,  0x8990, 0xD088} ,
{SENSOR_WORD_WRITE,  0x8992, 0x8800} ,
{SENSOR_WORD_WRITE,  0x8994, 0xE803} ,
{SENSOR_WORD_WRITE,  0x8996, 0x0E0F} ,
{SENSOR_WORD_WRITE,  0x8998, 0x1080} ,
{SENSOR_WORD_WRITE,  0x899A, 0xD087} ,
{SENSOR_WORD_WRITE,  0x899C, 0x8000} ,
{SENSOR_WORD_WRITE,  0x899E, 0x8002} ,
{SENSOR_WORD_WRITE,  0x89A0, 0x7840} ,
{SENSOR_WORD_WRITE,  0x89A2, 0x0115} ,
{SENSOR_WORD_WRITE,  0x89A4, 0x06C4} ,
{SENSOR_WORD_WRITE,  0x89A6, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x89A8, 0xC0F1} ,
{SENSOR_WORD_WRITE,  0x89AA, 0x08AA} ,
{SENSOR_WORD_WRITE,  0x89AC, 0x06C4} ,
{SENSOR_WORD_WRITE,  0x89AE, 0xD683} ,
{SENSOR_WORD_WRITE,  0x89B0, 0x8E01} ,
{SENSOR_WORD_WRITE,  0x89B2, 0xB8A4} ,
{SENSOR_WORD_WRITE,  0x89B4, 0xAE01} ,
{SENSOR_WORD_WRITE,  0x89B6, 0x8E09} ,
{SENSOR_WORD_WRITE,  0x89B8, 0xB8E0} ,
{SENSOR_WORD_WRITE,  0x89BA, 0xF29B} ,
{SENSOR_WORD_WRITE,  0x89BC, 0xD57B} ,
{SENSOR_WORD_WRITE,  0x89BE, 0x153A} ,
{SENSOR_WORD_WRITE,  0x89C0, 0x1080} ,
{SENSOR_WORD_WRITE,  0x89C2, 0x153B} ,
{SENSOR_WORD_WRITE,  0x89C4, 0x1081} ,
{SENSOR_WORD_WRITE,  0x89C6, 0xB808} ,
{SENSOR_WORD_WRITE,  0x89C8, 0x7825} ,
{SENSOR_WORD_WRITE,  0x89CA, 0x16B8} ,
{SENSOR_WORD_WRITE,  0x89CC, 0x1101} ,
{SENSOR_WORD_WRITE,  0x89CE, 0x092D} ,
{SENSOR_WORD_WRITE,  0x89D0, 0x0003} ,
{SENSOR_WORD_WRITE,  0x89D2, 0x16B0} ,
{SENSOR_WORD_WRITE,  0x89D4, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89D6, 0x1E3C} ,
{SENSOR_WORD_WRITE,  0x89D8, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89DA, 0x16B1} ,
{SENSOR_WORD_WRITE,  0x89DC, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89DE, 0x1E3D} ,
{SENSOR_WORD_WRITE,  0x89E0, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89E2, 0x16B4} ,
{SENSOR_WORD_WRITE,  0x89E4, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89E6, 0x1E3E} ,
{SENSOR_WORD_WRITE,  0x89E8, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89EA, 0x16B5} ,
{SENSOR_WORD_WRITE,  0x89EC, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89EE, 0x1E3F} ,
{SENSOR_WORD_WRITE,  0x89F0, 0x1082} ,
{SENSOR_WORD_WRITE,  0x89F2, 0x8E40} ,
{SENSOR_WORD_WRITE,  0x89F4, 0xBAA6} ,
{SENSOR_WORD_WRITE,  0x89F6, 0xAE40} ,
{SENSOR_WORD_WRITE,  0x89F8, 0x098F} ,
{SENSOR_WORD_WRITE,  0x89FA, 0x0022} ,
{SENSOR_WORD_WRITE,  0x89FC, 0x16BA} ,
{SENSOR_WORD_WRITE,  0x89FE, 0x1102} ,
{SENSOR_WORD_WRITE,  0x8A00, 0x0A87} ,
{SENSOR_WORD_WRITE,  0x8A02, 0x0003} ,
{SENSOR_WORD_WRITE,  0x8A04, 0x16B2} ,
{SENSOR_WORD_WRITE,  0x8A06, 0x1084} ,
{SENSOR_WORD_WRITE,  0x8A08, 0x09DE} ,
{SENSOR_WORD_WRITE,  0x8A0A, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8A0C, 0x16B0} ,
{SENSOR_WORD_WRITE,  0x8A0E, 0x1083} ,
{SENSOR_WORD_WRITE,  0x8A10, 0x1E3C} ,
{SENSOR_WORD_WRITE,  0x8A12, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8A14, 0x153A} ,
{SENSOR_WORD_WRITE,  0x8A16, 0x1080} ,
{SENSOR_WORD_WRITE,  0x8A18, 0x153B} ,
{SENSOR_WORD_WRITE,  0x8A1A, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8A1C, 0x16B3} ,
{SENSOR_WORD_WRITE,  0x8A1E, 0x1084} ,
{SENSOR_WORD_WRITE,  0x8A20, 0xB808} ,
{SENSOR_WORD_WRITE,  0x8A22, 0x7825} ,
{SENSOR_WORD_WRITE,  0x8A24, 0x16B8} ,
{SENSOR_WORD_WRITE,  0x8A26, 0x1101} ,
{SENSOR_WORD_WRITE,  0x8A28, 0x16BA} ,
{SENSOR_WORD_WRITE,  0x8A2A, 0x1102} ,
{SENSOR_WORD_WRITE,  0x8A2C, 0x09BA} ,
{SENSOR_WORD_WRITE,  0x8A2E, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8A30, 0x16B1} ,
{SENSOR_WORD_WRITE,  0x8A32, 0x1083} ,
{SENSOR_WORD_WRITE,  0x8A34, 0x1E3D} ,
{SENSOR_WORD_WRITE,  0x8A36, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8A38, 0x153A} ,
{SENSOR_WORD_WRITE,  0x8A3A, 0x1080} ,
{SENSOR_WORD_WRITE,  0x8A3C, 0x153B} ,
{SENSOR_WORD_WRITE,  0x8A3E, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8A40, 0x16B6} ,
{SENSOR_WORD_WRITE,  0x8A42, 0x1084} ,
{SENSOR_WORD_WRITE,  0x8A44, 0xB808} ,
{SENSOR_WORD_WRITE,  0x8A46, 0x7825} ,
{SENSOR_WORD_WRITE,  0x8A48, 0x16B8} ,
{SENSOR_WORD_WRITE,  0x8A4A, 0x1101} ,
{SENSOR_WORD_WRITE,  0x8A4C, 0x16BA} ,
{SENSOR_WORD_WRITE,  0x8A4E, 0x1102} ,
{SENSOR_WORD_WRITE,  0x8A50, 0x0996} ,
{SENSOR_WORD_WRITE,  0x8A52, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8A54, 0x16B4} ,
{SENSOR_WORD_WRITE,  0x8A56, 0x1083} ,
{SENSOR_WORD_WRITE,  0x8A58, 0x1E3E} ,
{SENSOR_WORD_WRITE,  0x8A5A, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8A5C, 0x153A} ,
{SENSOR_WORD_WRITE,  0x8A5E, 0x1080} ,
{SENSOR_WORD_WRITE,  0x8A60, 0x153B} ,
{SENSOR_WORD_WRITE,  0x8A62, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8A64, 0x16B7} ,
{SENSOR_WORD_WRITE,  0x8A66, 0x1084} ,
{SENSOR_WORD_WRITE,  0x8A68, 0xB808} ,
{SENSOR_WORD_WRITE,  0x8A6A, 0x7825} ,
{SENSOR_WORD_WRITE,  0x8A6C, 0x16B8} ,
{SENSOR_WORD_WRITE,  0x8A6E, 0x1101} ,
{SENSOR_WORD_WRITE,  0x8A70, 0x16BA} ,
{SENSOR_WORD_WRITE,  0x8A72, 0x1102} ,
{SENSOR_WORD_WRITE,  0x8A74, 0x0972} ,
{SENSOR_WORD_WRITE,  0x8A76, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8A78, 0x16B5} ,
{SENSOR_WORD_WRITE,  0x8A7A, 0x1083} ,
{SENSOR_WORD_WRITE,  0x8A7C, 0x1E3F} ,
{SENSOR_WORD_WRITE,  0x8A7E, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8A80, 0x8E00} ,
{SENSOR_WORD_WRITE,  0x8A82, 0xB8A6} ,
{SENSOR_WORD_WRITE,  0x8A84, 0xAE00} ,
{SENSOR_WORD_WRITE,  0x8A86, 0x153A} ,
{SENSOR_WORD_WRITE,  0x8A88, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8A8A, 0x153B} ,
{SENSOR_WORD_WRITE,  0x8A8C, 0x1080} ,
{SENSOR_WORD_WRITE,  0x8A8E, 0xB908} ,
{SENSOR_WORD_WRITE,  0x8A90, 0x7905} ,
{SENSOR_WORD_WRITE,  0x8A92, 0x16BA} ,
{SENSOR_WORD_WRITE,  0x8A94, 0x1100} ,
{SENSOR_WORD_WRITE,  0x8A96, 0x085B} ,
{SENSOR_WORD_WRITE,  0x8A98, 0x0042} ,
{SENSOR_WORD_WRITE,  0x8A9A, 0xD049} ,
{SENSOR_WORD_WRITE,  0x8A9C, 0x9E31} ,
{SENSOR_WORD_WRITE,  0x8A9E, 0x904D} ,
{SENSOR_WORD_WRITE,  0x8AA0, 0x0A2B} ,
{SENSOR_WORD_WRITE,  0x8AA2, 0x0063} ,
{SENSOR_WORD_WRITE,  0x8AA4, 0x8E00} ,
{SENSOR_WORD_WRITE,  0x8AA6, 0x16B0} ,
{SENSOR_WORD_WRITE,  0x8AA8, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8AAA, 0x1E3C} ,
{SENSOR_WORD_WRITE,  0x8AAC, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8AAE, 0x16B1} ,
{SENSOR_WORD_WRITE,  0x8AB0, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8AB2, 0x1E3D} ,
{SENSOR_WORD_WRITE,  0x8AB4, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8AB6, 0x16B4} ,
{SENSOR_WORD_WRITE,  0x8AB8, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8ABA, 0x1E3E} ,
{SENSOR_WORD_WRITE,  0x8ABC, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8ABE, 0x16B5} ,
{SENSOR_WORD_WRITE,  0x8AC0, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8AC2, 0x1E3F} ,
{SENSOR_WORD_WRITE,  0x8AC4, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8AC6, 0xB886} ,
{SENSOR_WORD_WRITE,  0x8AC8, 0xF012} ,
{SENSOR_WORD_WRITE,  0x8ACA, 0x16B2} ,
{SENSOR_WORD_WRITE,  0x8ACC, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8ACE, 0xB8A6} ,
{SENSOR_WORD_WRITE,  0x8AD0, 0x1E3C} ,
{SENSOR_WORD_WRITE,  0x8AD2, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8AD4, 0x16B3} ,
{SENSOR_WORD_WRITE,  0x8AD6, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8AD8, 0x1E3D} ,
{SENSOR_WORD_WRITE,  0x8ADA, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8ADC, 0x16B6} ,
{SENSOR_WORD_WRITE,  0x8ADE, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8AE0, 0x1E3E} ,
{SENSOR_WORD_WRITE,  0x8AE2, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8AE4, 0x16B7} ,
{SENSOR_WORD_WRITE,  0x8AE6, 0x1081} ,
{SENSOR_WORD_WRITE,  0x8AE8, 0x1E3F} ,
{SENSOR_WORD_WRITE,  0x8AEA, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8AEC, 0xAE00} ,
{SENSOR_WORD_WRITE,  0x8AEE, 0x0842} ,
{SENSOR_WORD_WRITE,  0x8AF0, 0x01C4} ,
{SENSOR_WORD_WRITE,  0x8AF2, 0x07CD} ,
{SENSOR_WORD_WRITE,  0x8AF4, 0x0684} ,
{SENSOR_WORD_WRITE,  0x8AF6, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x8AF8, 0xC0F1} ,
{SENSOR_WORD_WRITE,  0x8AFA, 0x0F56} ,
{SENSOR_WORD_WRITE,  0x8AFC, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8AFE, 0xDA14} ,
{SENSOR_WORD_WRITE,  0x8B00, 0xD02B} ,
{SENSOR_WORD_WRITE,  0x8B02, 0xDE00} ,
{SENSOR_WORD_WRITE,  0x8B04, 0xD12F} ,
{SENSOR_WORD_WRITE,  0x8B06, 0x2E41} ,
{SENSOR_WORD_WRITE,  0x8B08, 0x120C} ,
{SENSOR_WORD_WRITE,  0x8B0A, 0xA895} ,
{SENSOR_WORD_WRITE,  0x8B0C, 0xD52E} ,
{SENSOR_WORD_WRITE,  0x8B0E, 0xA8D4} ,
{SENSOR_WORD_WRITE,  0x8B10, 0xA8D6} ,
{SENSOR_WORD_WRITE,  0x8B12, 0x0CE2} ,
{SENSOR_WORD_WRITE,  0x8B14, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8B16, 0x2555} ,
{SENSOR_WORD_WRITE,  0x8B18, 0x1440} ,
{SENSOR_WORD_WRITE,  0x8B1A, 0xD02C} ,
{SENSOR_WORD_WRITE,  0x8B1C, 0x2555} ,
{SENSOR_WORD_WRITE,  0x8B1E, 0x1441} ,
{SENSOR_WORD_WRITE,  0x8B20, 0x77A9} ,
{SENSOR_WORD_WRITE,  0x8B22, 0xA515} ,
{SENSOR_WORD_WRITE,  0x8B24, 0xD024} ,
{SENSOR_WORD_WRITE,  0x8B26, 0xA020} ,
{SENSOR_WORD_WRITE,  0x8B28, 0xD129} ,
{SENSOR_WORD_WRITE,  0x8B2A, 0x70E9} ,
{SENSOR_WORD_WRITE,  0x8B2C, 0x0CC6} ,
{SENSOR_WORD_WRITE,  0x8B2E, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8B30, 0xDA44} ,
{SENSOR_WORD_WRITE,  0x8B32, 0xD028} ,
{SENSOR_WORD_WRITE,  0x8B34, 0xD121} ,
{SENSOR_WORD_WRITE,  0x8B36, 0xA502} ,
{SENSOR_WORD_WRITE,  0x8B38, 0xD027} ,
{SENSOR_WORD_WRITE,  0x8B3A, 0xA0E0} ,
{SENSOR_WORD_WRITE,  0x8B3C, 0xD027} ,
{SENSOR_WORD_WRITE,  0x8B3E, 0xB0CB} ,
{SENSOR_WORD_WRITE,  0x8B40, 0x8900} ,
{SENSOR_WORD_WRITE,  0x8B42, 0xDB08} ,
{SENSOR_WORD_WRITE,  0x8B44, 0xDAF0} ,
{SENSOR_WORD_WRITE,  0x8B46, 0x19B0} ,
{SENSOR_WORD_WRITE,  0x8B48, 0x00C2} ,
{SENSOR_WORD_WRITE,  0x8B4A, 0xB8A6} ,
{SENSOR_WORD_WRITE,  0x8B4C, 0xA900} ,
{SENSOR_WORD_WRITE,  0x8B4E, 0xD851} ,
{SENSOR_WORD_WRITE,  0x8B50, 0x19B2} ,
{SENSOR_WORD_WRITE,  0x8B52, 0x0002} ,
{SENSOR_WORD_WRITE,  0x8B54, 0xD852} ,
{SENSOR_WORD_WRITE,  0x8B56, 0x19B3} ,
{SENSOR_WORD_WRITE,  0x8B58, 0x0002} ,
{SENSOR_WORD_WRITE,  0x8B5A, 0xD855} ,
{SENSOR_WORD_WRITE,  0x8B5C, 0x19B6} ,
{SENSOR_WORD_WRITE,  0x8B5E, 0x0002} ,
{SENSOR_WORD_WRITE,  0x8B60, 0xD856} ,
{SENSOR_WORD_WRITE,  0x8B62, 0x19B7} ,
{SENSOR_WORD_WRITE,  0x8B64, 0x0002} ,
{SENSOR_WORD_WRITE,  0x8B66, 0xD896} ,
{SENSOR_WORD_WRITE,  0x8B68, 0x19B8} ,
{SENSOR_WORD_WRITE,  0x8B6A, 0x0004} ,
{SENSOR_WORD_WRITE,  0x8B6C, 0xD814} ,
{SENSOR_WORD_WRITE,  0x8B6E, 0x19BA} ,
{SENSOR_WORD_WRITE,  0x8B70, 0x0004} ,
{SENSOR_WORD_WRITE,  0x8B72, 0xD805} ,
{SENSOR_WORD_WRITE,  0x8B74, 0xB111} ,
{SENSOR_WORD_WRITE,  0x8B76, 0x19B1} ,
{SENSOR_WORD_WRITE,  0x8B78, 0x0082} ,
{SENSOR_WORD_WRITE,  0x8B7A, 0x19B4} ,
{SENSOR_WORD_WRITE,  0x8B7C, 0x00C2} ,
{SENSOR_WORD_WRITE,  0x8B7E, 0x19B5} ,
{SENSOR_WORD_WRITE,  0x8B80, 0x0082} ,
{SENSOR_WORD_WRITE,  0x8B82, 0xD117} ,
{SENSOR_WORD_WRITE,  0x8B84, 0x2556} ,
{SENSOR_WORD_WRITE,  0x8B86, 0x12C0} ,
{SENSOR_WORD_WRITE,  0x8B88, 0x0C6A} ,
{SENSOR_WORD_WRITE,  0x8B8A, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8B8C, 0xDA2C} ,
{SENSOR_WORD_WRITE,  0x8B8E, 0xD015} ,
{SENSOR_WORD_WRITE,  0x8B90, 0x2556} ,
{SENSOR_WORD_WRITE,  0x8B92, 0x12C1} ,
{SENSOR_WORD_WRITE,  0x8B94, 0xA519} ,
{SENSOR_WORD_WRITE,  0x8B96, 0xD014} ,
{SENSOR_WORD_WRITE,  0x8B98, 0x071D} ,
{SENSOR_WORD_WRITE,  0x8B9A, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8B9C, 0xA020} ,
{SENSOR_WORD_WRITE,  0x8B9E, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x8BA0, 0xFF00} ,
{SENSOR_WORD_WRITE,  0x8BA2, 0x33CC} ,
{SENSOR_WORD_WRITE,  0x8BA4, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BA6, 0x0658} ,
{SENSOR_WORD_WRITE,  0x8BA8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BAA, 0x0250} ,
{SENSOR_WORD_WRITE,  0x8BAC, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BAE, 0x0644} ,
{SENSOR_WORD_WRITE,  0x8BB0, 0x8000} ,
{SENSOR_WORD_WRITE,  0x8BB2, 0x0168} ,
{SENSOR_WORD_WRITE,  0x8BB4, 0x8000} ,
{SENSOR_WORD_WRITE,  0x8BB6, 0x0164} ,
{SENSOR_WORD_WRITE,  0x8BB8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BBA, 0x0314} ,
{SENSOR_WORD_WRITE,  0x8BBC, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BBE, 0x050C} ,
{SENSOR_WORD_WRITE,  0x8BC0, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8BC2, 0xF978} ,
{SENSOR_WORD_WRITE,  0x8BC4, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BC6, 0x0D20} ,
{SENSOR_WORD_WRITE,  0x8BC8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BCA, 0x0918} ,
{SENSOR_WORD_WRITE,  0x8BCC, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8BCE, 0xF9AC} ,
{SENSOR_WORD_WRITE,  0x8BD0, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BD2, 0x08D0} ,
{SENSOR_WORD_WRITE,  0x8BD4, 0x8000} ,
{SENSOR_WORD_WRITE,  0x8BD6, 0x016C} ,
{SENSOR_WORD_WRITE,  0x8BD8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BDA, 0x0694} ,
{SENSOR_WORD_WRITE,  0x8BDC, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8BDE, 0xF444} ,
{SENSOR_WORD_WRITE,  0x8BE0, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8BE2, 0x09A8} ,
{SENSOR_WORD_WRITE,  0x8BE4, 0x8000} ,
{SENSOR_WORD_WRITE,  0x8BE6, 0x009C} ,
{SENSOR_WORD_WRITE,  0x8BE8, 0xC0F1} ,
{SENSOR_WORD_WRITE,  0x8BEA, 0x0E5A} ,
{SENSOR_WORD_WRITE,  0x8BEC, 0x0684} ,
{SENSOR_WORD_WRITE,  0x8BEE, 0xD633} ,
{SENSOR_WORD_WRITE,  0x8BF0, 0x7708} ,
{SENSOR_WORD_WRITE,  0x8BF2, 0x8E01} ,
{SENSOR_WORD_WRITE,  0x8BF4, 0x1604} ,
{SENSOR_WORD_WRITE,  0x8BF6, 0x1091} ,
{SENSOR_WORD_WRITE,  0x8BF8, 0x2046} ,
{SENSOR_WORD_WRITE,  0x8BFA, 0x00C1} ,
{SENSOR_WORD_WRITE,  0x8BFC, 0x202F} ,
{SENSOR_WORD_WRITE,  0x8BFE, 0x2047} ,
{SENSOR_WORD_WRITE,  0x8C00, 0xAE21} ,
{SENSOR_WORD_WRITE,  0x8C02, 0x0F8F} ,
{SENSOR_WORD_WRITE,  0x8C04, 0x1440} ,
{SENSOR_WORD_WRITE,  0x8C06, 0x8EAA} ,
{SENSOR_WORD_WRITE,  0x8C08, 0x8E0B} ,
{SENSOR_WORD_WRITE,  0x8C0A, 0x224A} ,
{SENSOR_WORD_WRITE,  0x8C0C, 0x2040} ,
{SENSOR_WORD_WRITE,  0x8C0E, 0x8E2D} ,
{SENSOR_WORD_WRITE,  0x8C10, 0xBD08} ,
{SENSOR_WORD_WRITE,  0x8C12, 0x7D05} ,
{SENSOR_WORD_WRITE,  0x8C14, 0x8E0C} ,
{SENSOR_WORD_WRITE,  0x8C16, 0xB808} ,
{SENSOR_WORD_WRITE,  0x8C18, 0x7825} ,
{SENSOR_WORD_WRITE,  0x8C1A, 0x7510} ,
{SENSOR_WORD_WRITE,  0x8C1C, 0x22C2} ,
{SENSOR_WORD_WRITE,  0x8C1E, 0x248C} ,
{SENSOR_WORD_WRITE,  0x8C20, 0x081D} ,
{SENSOR_WORD_WRITE,  0x8C22, 0x0363} ,
{SENSOR_WORD_WRITE,  0x8C24, 0xD9FF} ,
{SENSOR_WORD_WRITE,  0x8C26, 0x2502} ,
{SENSOR_WORD_WRITE,  0x8C28, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8C2A, 0x2A05} ,
{SENSOR_WORD_WRITE,  0x8C2C, 0x03FE} ,
{SENSOR_WORD_WRITE,  0x8C2E, 0x0EFA} ,
{SENSOR_WORD_WRITE,  0x8C30, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8C32, 0x702F} ,
{SENSOR_WORD_WRITE,  0x8C34, 0x7810} ,
{SENSOR_WORD_WRITE,  0x8C36, 0x7D02} ,
{SENSOR_WORD_WRITE,  0x8C38, 0x7DB0} ,
{SENSOR_WORD_WRITE,  0x8C3A, 0xF00B} ,
{SENSOR_WORD_WRITE,  0x8C3C, 0x78A2} ,
{SENSOR_WORD_WRITE,  0x8C3E, 0x2805} ,
{SENSOR_WORD_WRITE,  0x8C40, 0x03FE} ,
{SENSOR_WORD_WRITE,  0x8C42, 0x0EE6} ,
{SENSOR_WORD_WRITE,  0x8C44, 0x06A4} ,
{SENSOR_WORD_WRITE,  0x8C46, 0x702F} ,
{SENSOR_WORD_WRITE,  0x8C48, 0x7810} ,
{SENSOR_WORD_WRITE,  0x8C4A, 0x651D} ,
{SENSOR_WORD_WRITE,  0x8C4C, 0x7DB0} ,
{SENSOR_WORD_WRITE,  0x8C4E, 0x7DAF} ,
{SENSOR_WORD_WRITE,  0x8C50, 0x8E08} ,
{SENSOR_WORD_WRITE,  0x8C52, 0xBD06} ,
{SENSOR_WORD_WRITE,  0x8C54, 0xD11A} ,
{SENSOR_WORD_WRITE,  0x8C56, 0xB8C3} ,
{SENSOR_WORD_WRITE,  0x8C58, 0x78A5} ,
{SENSOR_WORD_WRITE,  0x8C5A, 0xB88F} ,
{SENSOR_WORD_WRITE,  0x8C5C, 0x1908} ,
{SENSOR_WORD_WRITE,  0x8C5E, 0x0024} ,
{SENSOR_WORD_WRITE,  0x8C60, 0x2841} ,
{SENSOR_WORD_WRITE,  0x8C62, 0x0201} ,
{SENSOR_WORD_WRITE,  0x8C64, 0x1E26} ,
{SENSOR_WORD_WRITE,  0x8C66, 0x1042} ,
{SENSOR_WORD_WRITE,  0x8C68, 0x0F15} ,
{SENSOR_WORD_WRITE,  0x8C6A, 0x1463} ,
{SENSOR_WORD_WRITE,  0x8C6C, 0x1E27} ,
{SENSOR_WORD_WRITE,  0x8C6E, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8C70, 0x224C} ,
{SENSOR_WORD_WRITE,  0x8C72, 0xA000} ,
{SENSOR_WORD_WRITE,  0x8C74, 0x224A} ,
{SENSOR_WORD_WRITE,  0x8C76, 0x2040} ,
{SENSOR_WORD_WRITE,  0x8C78, 0x22C2} ,
{SENSOR_WORD_WRITE,  0x8C7A, 0x2482} ,
{SENSOR_WORD_WRITE,  0x8C7C, 0x204F} ,
{SENSOR_WORD_WRITE,  0x8C7E, 0x2040} ,
{SENSOR_WORD_WRITE,  0x8C80, 0x224C} ,
{SENSOR_WORD_WRITE,  0x8C82, 0xA000} ,
{SENSOR_WORD_WRITE,  0x8C84, 0xB8A2} ,
{SENSOR_WORD_WRITE,  0x8C86, 0xF204} ,
{SENSOR_WORD_WRITE,  0x8C88, 0x2045} ,
{SENSOR_WORD_WRITE,  0x8C8A, 0x2180} ,
{SENSOR_WORD_WRITE,  0x8C8C, 0xAE01} ,
{SENSOR_WORD_WRITE,  0x8C8E, 0x0A82} ,
{SENSOR_WORD_WRITE,  0x8C90, 0xFFE3} ,
{SENSOR_WORD_WRITE,  0x8C92, 0x70E9} ,
{SENSOR_WORD_WRITE,  0x8C94, 0x0609} ,
{SENSOR_WORD_WRITE,  0x8C96, 0x0684} ,
{SENSOR_WORD_WRITE,  0x8C98, 0xC0F1} ,
{SENSOR_WORD_WRITE,  0x8C9A, 0xD00A} ,
{SENSOR_WORD_WRITE,  0x8C9C, 0xD20A} ,
{SENSOR_WORD_WRITE,  0x8C9E, 0xD10B} ,
{SENSOR_WORD_WRITE,  0x8CA0, 0xA040} ,
{SENSOR_WORD_WRITE,  0x8CA2, 0x890C} ,
{SENSOR_WORD_WRITE,  0x8CA4, 0x080F} ,
{SENSOR_WORD_WRITE,  0x8CA6, 0x01DE} ,
{SENSOR_WORD_WRITE,  0x8CA8, 0xB8A7} ,
{SENSOR_WORD_WRITE,  0x8CAA, 0x8243} ,
{SENSOR_WORD_WRITE,  0x8CAC, 0xA90C} ,
{SENSOR_WORD_WRITE,  0x8CAE, 0x7A60} ,
{SENSOR_WORD_WRITE,  0x8CB0, 0x890C} ,
{SENSOR_WORD_WRITE,  0x8CB2, 0xC0D1} ,
{SENSOR_WORD_WRITE,  0x8CB4, 0x7EE0} ,
{SENSOR_WORD_WRITE,  0x8CB6, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x8CB8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8CBA, 0x0158} ,
{SENSOR_WORD_WRITE,  0x8CBC, 0xFF00} ,
{SENSOR_WORD_WRITE,  0x8CBE, 0x0618} ,
{SENSOR_WORD_WRITE,  0x8CC0, 0x8000} ,
{SENSOR_WORD_WRITE,  0x8CC2, 0x0008} ,
{SENSOR_WORD_WRITE,  0x8CC4, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8CC6, 0x0D10} ,
{SENSOR_WORD_WRITE,  0x8CC8, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8CCA, 0x0174} ,
{SENSOR_WORD_WRITE,  0x8CCC, 0xE280} ,
{SENSOR_WORD_WRITE,  0x8CCE, 0x24CA} ,
{SENSOR_WORD_WRITE,  0x8CD0, 0x7082} ,
{SENSOR_WORD_WRITE,  0x8CD2, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x8CD4, 0x20E8} ,
{SENSOR_WORD_WRITE,  0x8CD6, 0x01A2} ,
{SENSOR_WORD_WRITE,  0x8CD8, 0x1002} ,
{SENSOR_WORD_WRITE,  0x8CDA, 0x0D02} ,
{SENSOR_WORD_WRITE,  0x8CDC, 0x1902} ,
{SENSOR_WORD_WRITE,  0x8CDE, 0x0094} ,
{SENSOR_WORD_WRITE,  0x8CE0, 0x7FE0} ,
{SENSOR_WORD_WRITE,  0x8CE2, 0x7028} ,
{SENSOR_WORD_WRITE,  0x8CE4, 0x7308} ,
{SENSOR_WORD_WRITE,  0x8CE6, 0x1000} ,
{SENSOR_WORD_WRITE,  0x8CE8, 0x0900} ,
{SENSOR_WORD_WRITE,  0x8CEA, 0x7904} ,
{SENSOR_WORD_WRITE,  0x8CEC, 0x7947} ,
{SENSOR_WORD_WRITE,  0x8CEE, 0x1B00} ,
{SENSOR_WORD_WRITE,  0x8CF0, 0x0064} ,
{SENSOR_WORD_WRITE,  0x8CF2, 0x7EE0} ,
{SENSOR_WORD_WRITE,  0x8CF4, 0xE280} ,
{SENSOR_WORD_WRITE,  0x8CF6, 0x24CA} ,
{SENSOR_WORD_WRITE,  0x8CF8, 0x7082} ,
{SENSOR_WORD_WRITE,  0x8CFA, 0x78E0} ,
{SENSOR_WORD_WRITE,  0x8CFC, 0x20E8} ,
{SENSOR_WORD_WRITE,  0x8CFE, 0x01A2} ,
{SENSOR_WORD_WRITE,  0x8D00, 0x1102} ,
{SENSOR_WORD_WRITE,  0x8D02, 0x0502} ,
{SENSOR_WORD_WRITE,  0x8D04, 0x1802} ,
{SENSOR_WORD_WRITE,  0x8D06, 0x00B4} ,
{SENSOR_WORD_WRITE,  0x8D08, 0x7FE0} ,
{SENSOR_WORD_WRITE,  0x8D0A, 0x7028} ,
{SENSOR_WORD_WRITE,  0x8D0C, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8D0E, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8D10, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8D12, 0x0C98} ,
{SENSOR_WORD_WRITE,  0x8D14, 0xFF80} ,
{SENSOR_WORD_WRITE,  0x8D16, 0x0BE8} ,
{SENSOR_WORD_WRITE,  0x8D18, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8D1A, 0x08DC} ,
{SENSOR_WORD_WRITE,  0x8D1C, 0x0000} ,
{SENSOR_WORD_WRITE,  0x8D1E, 0x0998} ,

{SENSOR_WORD_WRITE,  0x098E, 0x0016} ,  	// LOGICAL_ADDRESS_ACCESS [MODDRESS_LO]
{SENSOR_WORD_WRITE,  0x8016, 0x086C} ,  	// MON_ADDRESS_LO
{SENSOR_WORD_WRITE,  0x8002, 0x0001} ,  	// MON_CMD
{SENSOR_WAIT_MS,0,150}, //DELAY= 150

// Patch-specific defaults that need to changed
{SENSOR_WORD_WRITE,  0x098E, 0xC40C} ,     // LOGICAL_ADDRESS_ACCESS
{SENSOR_WORD_WRITE,  0xC40C, 0x00FF} ,     // AFM_POS_MAX
{SENSOR_WORD_WRITE,  0xC40A, 0x0000} ,     // AFM_POS_MIN

//;[Char_settings]
//;[New DAC]
{SENSOR_WORD_WRITE,  0x30D4, 0x9080} ,  	// COLUMN_CORRECTION
{SENSOR_WORD_WRITE,  0x316E, 0xC400} ,  	// DAC_ECL
{SENSOR_WORD_WRITE,  0x305E, 0x10A0} ,  	// GLOBAL_GAIN
{SENSOR_WORD_WRITE,  0x3E00, 0x0010} ,  	// SAMP_CONTROL
{SENSOR_WORD_WRITE,  0x3E02, 0xED02} ,  	// SAMP_ADDR_EN
{SENSOR_WORD_WRITE,  0x3E04, 0xC88C} ,  	// SAMP_RD1_SIG
{SENSOR_WORD_WRITE,  0x3E06, 0xC88C} ,  	// SAMP_RD1_SIG_BOOST
{SENSOR_WORD_WRITE,  0x3E08, 0x700A} ,  	// SAMP_RD1_RST
{SENSOR_WORD_WRITE,  0x3E0A, 0x701E} ,  	// SAMP_RD1_RST_BOOST
{SENSOR_WORD_WRITE,  0x3E0C, 0x00FF} ,  	// SAMP_RST1_EN
{SENSOR_WORD_WRITE,  0x3E0E, 0x00FF} ,  	// SAMP_RST1_BOOST
{SENSOR_WORD_WRITE,  0x3E10, 0x00FF} ,  	// SAMP_RST1_CLOOP_SH
{SENSOR_WORD_WRITE,  0x3E12, 0x0000} ,  	// SAMP_RST_BOOST_SEQ
{SENSOR_WORD_WRITE,  0x3E14, 0xC78C} ,  	// SAMP_SAMP1_SIG
{SENSOR_WORD_WRITE,  0x3E16, 0x6E06} ,  	// SAMP_SAMP1_RST
{SENSOR_WORD_WRITE,  0x3E18, 0xA58C} ,  	// SAMP_TX_EN
{SENSOR_WORD_WRITE,  0x3E1A, 0xA58E} ,  	// SAMP_TX_BOOST
{SENSOR_WORD_WRITE,  0x3E1C, 0xA58E} ,  	// SAMP_TX_CLOOP_SH
{SENSOR_WORD_WRITE,  0x3E1E, 0xC0D0} ,  	// SAMP_TX_BOOST_SEQ
{SENSOR_WORD_WRITE,  0x3E20, 0xEB00} ,  	// SAMP_VLN_EN
{SENSOR_WORD_WRITE,  0x3E22, 0x00FF} ,  	// SAMP_VLN_HOLD
{SENSOR_WORD_WRITE,  0x3E24, 0xEB02} ,  	// SAMP_VCL_EN
{SENSOR_WORD_WRITE,  0x3E26, 0xEA02} ,  	// SAMP_COLCLAMP
{SENSOR_WORD_WRITE,  0x3E28, 0xEB0A} ,  	// SAMP_SH_VCL
{SENSOR_WORD_WRITE,  0x3E2A, 0xEC01} ,  	// SAMP_SH_VREF
{SENSOR_WORD_WRITE,  0x3E2C, 0xEB01} ,  	// SAMP_SH_VBST
{SENSOR_WORD_WRITE,  0x3E2E, 0x00FF} ,  	// SAMP_SPARE
{SENSOR_WORD_WRITE,  0x3E30, 0x00F3} ,  	// SAMP_READOUT
{SENSOR_WORD_WRITE,  0x3E32, 0x3DFA} ,  	// SAMP_RESET_DONE
{SENSOR_WORD_WRITE,  0x3E34, 0x00FF} ,  	// SAMP_VLN_CLAMP
{SENSOR_WORD_WRITE,  0x3E36, 0x00F3} ,  	// SAMP_ASC_INT
{SENSOR_WORD_WRITE,  0x3E38, 0x0000} ,  	// SAMP_RS_CLOOP_SH_R
{SENSOR_WORD_WRITE,  0x3E3A, 0xF802} ,  	// SAMP_RS_CLOOP_SH
{SENSOR_WORD_WRITE,  0x3E3C, 0x0FFF} ,  	// SAMP_RS_BOOST_SEQ
{SENSOR_WORD_WRITE,  0x3E3E, 0xEA10} ,  	// SAMP_TXLO_GND
{SENSOR_WORD_WRITE,  0x3E40, 0xEB05} ,  	// SAMP_VLN_PER_COL
{SENSOR_WORD_WRITE,  0x3E42, 0xE5C8} ,  	// SAMP_RD2_SIG
{SENSOR_WORD_WRITE,  0x3E44, 0xE5C8} ,  	// SAMP_RD2_SIG_BOOST
{SENSOR_WORD_WRITE,  0x3E46, 0x8C70} ,  	// SAMP_RD2_RST
{SENSOR_WORD_WRITE,  0x3E48, 0x8C71} ,  	// SAMP_RD2_RST_BOOST
{SENSOR_WORD_WRITE,  0x3E4A, 0x00FF} ,  	// SAMP_RST2_EN
{SENSOR_WORD_WRITE,  0x3E4C, 0x00FF} ,  	// SAMP_RST2_BOOST
{SENSOR_WORD_WRITE,  0x3E4E, 0x00FF} ,  	// SAMP_RST2_CLOOP_SH
{SENSOR_WORD_WRITE,  0x3E50, 0xE38D} ,  	// SAMP_SAMP2_SIG
{SENSOR_WORD_WRITE,  0x3E52, 0x8B0A} ,  	// SAMP_SAMP2_RST
{SENSOR_WORD_WRITE,  0x3E58, 0xEB0A} ,  	// SAMP_PIX_CLAMP_EN
{SENSOR_WORD_WRITE,  0x3E5C, 0x0A00} ,  	// SAMP_PIX_PULLUP_EN
{SENSOR_WORD_WRITE,  0x3E5E, 0x00FF} ,  	// SAMP_PIX_PULLDOWN_EN_R
{SENSOR_WORD_WRITE,  0x3E60, 0x00FF} ,  	// SAMP_PIX_PULLDOWN_EN_S
{SENSOR_WORD_WRITE,  0x3E90, 0x3C01} ,  	// RST_ADDR_EN
{SENSOR_WORD_WRITE,  0x3E92, 0x00FF} ,  	// RST_RST_EN
{SENSOR_WORD_WRITE,  0x3E94, 0x00FF} ,  	// RST_RST_BOOST
{SENSOR_WORD_WRITE,  0x3E96, 0x3C00} ,  	// RST_TX_EN
{SENSOR_WORD_WRITE,  0x3E98, 0x3C00} ,  	// RST_TX_BOOST
{SENSOR_WORD_WRITE,  0x3E9A, 0x3C00} ,  	// RST_TX_CLOOP_SH
{SENSOR_WORD_WRITE,  0x3E9C, 0xC0E0} ,  	// RST_TX_BOOST_SEQ
{SENSOR_WORD_WRITE,  0x3E9E, 0x00FF} ,  	// RST_RST_CLOOP_SH
{SENSOR_WORD_WRITE,  0x3EA0, 0x0000} ,  	// RST_RST_BOOST_SEQ
{SENSOR_WORD_WRITE,  0x3EA6, 0x3C00} ,  	// RST_PIX_PULLUP_EN
{SENSOR_WORD_WRITE,  0x3ED8, 0x3057} ,  	// DAC_LD_12_13
{SENSOR_WORD_WRITE,  0x316C, 0xB44F} ,  	// DAC_TXLO
{SENSOR_WORD_WRITE,  0x316E, 0xC6FF} ,  	// DAC_ECL
{SENSOR_WORD_WRITE,  0x3ED2, 0xEA0A} ,  	// DAC_LD_6_7
{SENSOR_WORD_WRITE,  0x3ED4, 0x00A3} ,  	// DAC_LD_8_9
{SENSOR_WORD_WRITE,  0x3EDC, 0x6020} ,  	// DAC_LD_16_17
{SENSOR_WORD_WRITE,  0x3EE6, 0xA541} ,  	// DAC_LD_26_27
{SENSOR_WORD_WRITE,  0x31E0, 0x0000} ,  	// PIX_DEF_ID
{SENSOR_WORD_WRITE,  0x3ED0, 0x2409} ,  	// DAC_LD_4_5
{SENSOR_WORD_WRITE,  0x3EDA, 0x6060} ,  	// DAC_LD_14_15
{SENSOR_WORD_WRITE,  0x3EDE, 0x0A49} ,  	// DAC_LD_18_19
{SENSOR_WORD_WRITE,  0x3EE0, 0x4910} ,  	// DAC_LD_20_21
{SENSOR_WORD_WRITE,  0x3EE2, 0x09D2} ,  	// DAC_LD_22_23
{SENSOR_WORD_WRITE,  0x30B6, 0x0008} ,  	// AUTOLR_CONTROL
{SENSOR_WORD_WRITE,  0x337C, 0x0006} ,  	// YUV_YCBCR_CONTROL
{SENSOR_WORD_WRITE,  0x3E1A, 0xA582} ,  	// SAMP_TX_BOOST
{SENSOR_WORD_WRITE,  0x3E2E, 0xEC05} ,  	// SAMP_SPARE
{SENSOR_WORD_WRITE,  0x3EE6, 0xA5C0} ,  	// DAC_LD_26_27
{SENSOR_WORD_WRITE,  0x316C, 0xB43F} ,  	// DAC_TXLO
{SENSOR_WORD_WRITE,  0x316E, 0xC6FF} ,  	// DAC_ECL


//;**********************************************************************************************************
//; [Section4]	} ,	//
//;**********************************************************************************************************
//;[Section4]
//;[Save PGA to Patch RAM]
// --Rev3, 03142011, Alias
// Modified PGA parameters and APGA settings according to new lens and IRCF
//APGA patch RAM LSC, Zone 0, A-light, start address is 0x1580 (5504)
{SENSOR_WORD_WRITE,  0x0982, 0x0000} ,	// ACCESS_CTL_STAT
{SENSOR_WORD_WRITE,  0x098A, 0x1580} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x7FEF} ,
{SENSOR_WORD_WRITE,  0x0992, 0x27AD} ,
{SENSOR_WORD_WRITE,  0x0994, 0x4EF1} ,
{SENSOR_WORD_WRITE,  0x0996, 0x164B} ,
{SENSOR_WORD_WRITE,  0x0998, 0x8731} ,
{SENSOR_WORD_WRITE,  0x099A, 0x7D8F} ,
{SENSOR_WORD_WRITE,  0x099C, 0xF84D} ,
{SENSOR_WORD_WRITE,  0x099E, 0x75D1} ,

{SENSOR_WORD_WRITE,  0x098A, 0x1590} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x038F} ,
{SENSOR_WORD_WRITE,  0x0992, 0xBE71} ,
{SENSOR_WORD_WRITE,  0x0994, 0x0030} ,
{SENSOR_WORD_WRITE,  0x0996, 0x5DCC} ,
{SENSOR_WORD_WRITE,  0x0998, 0x2A30} ,
{SENSOR_WORD_WRITE,  0x099A, 0x886E} ,
{SENSOR_WORD_WRITE,  0x099C, 0x9E6F} ,
{SENSOR_WORD_WRITE,  0x099E, 0x7B8F} ,

{SENSOR_WORD_WRITE,  0x098A, 0x15A0} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0xFA2D} ,
{SENSOR_WORD_WRITE,  0x0992, 0x6051} ,
{SENSOR_WORD_WRITE,  0x0994, 0x3EAC} ,
{SENSOR_WORD_WRITE,  0x0996, 0x8BD1} ,
{SENSOR_WORD_WRITE,  0x0998, 0xCFCC} ,
{SENSOR_WORD_WRITE,  0x099A, 0xC58E} ,
{SENSOR_WORD_WRITE,  0x099C, 0x82AF} ,
{SENSOR_WORD_WRITE,  0x099E, 0x750E} ,

{SENSOR_WORD_WRITE,  0x098A, 0x15B0} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x0711} ,
{SENSOR_WORD_WRITE,  0x0992, 0x43CC} ,
{SENSOR_WORD_WRITE,  0x0994, 0x036E} ,
{SENSOR_WORD_WRITE,  0x0996, 0x29ED} ,
{SENSOR_WORD_WRITE,  0x0998, 0x90CF} ,
{SENSOR_WORD_WRITE,  0x099A, 0x57AF} ,
{SENSOR_WORD_WRITE,  0x099C, 0x98CD} ,
{SENSOR_WORD_WRITE,  0x099E, 0x246C} ,

{SENSOR_WORD_WRITE,  0x098A, 0x15C0} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x4A4E} ,
{SENSOR_WORD_WRITE,  0x0992, 0x84EE} ,
{SENSOR_WORD_WRITE,  0x0994, 0x82EE} ,
{SENSOR_WORD_WRITE,  0x0996, 0x4D4A} ,
{SENSOR_WORD_WRITE,  0x0998, 0xF4EE} ,
{SENSOR_WORD_WRITE,  0x099A, 0x094E} ,
{SENSOR_WORD_WRITE,  0x099C, 0x652E} ,
{SENSOR_WORD_WRITE,  0x099E, 0x04CD} ,

{SENSOR_WORD_WRITE,  0x098A, 0x15D0} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x0B72} ,
{SENSOR_WORD_WRITE,  0x0992, 0x1BAF} ,
{SENSOR_WORD_WRITE,  0x0994, 0x8433} ,
{SENSOR_WORD_WRITE,  0x0996, 0x42EF} ,
{SENSOR_WORD_WRITE,  0x0998, 0x4D73} ,
{SENSOR_WORD_WRITE,  0x099A, 0x12D2} ,
{SENSOR_WORD_WRITE,  0x099C, 0xB7EE} ,
{SENSOR_WORD_WRITE,  0x099E, 0x8653} ,

{SENSOR_WORD_WRITE,  0x098A, 0x15E0} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x0A90} ,
{SENSOR_WORD_WRITE,  0x0992, 0x4FF3} ,
{SENSOR_WORD_WRITE,  0x0994, 0x3E71} ,
{SENSOR_WORD_WRITE,  0x0996, 0x7AAE} ,
{SENSOR_WORD_WRITE,  0x0998, 0xA772} ,
{SENSOR_WORD_WRITE,  0x099A, 0x55AF} ,
{SENSOR_WORD_WRITE,  0x099C, 0x1B93} ,
{SENSOR_WORD_WRITE,  0x099E, 0x0752} ,

{SENSOR_WORD_WRITE,  0x098A, 0x15F0} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0xE9AF} ,
{SENSOR_WORD_WRITE,  0x0992, 0xC7D2} ,
{SENSOR_WORD_WRITE,  0x0994, 0x3E11} ,
{SENSOR_WORD_WRITE,  0x0996, 0x68F2} ,
{SENSOR_WORD_WRITE,  0x0998, 0x31AD} ,
{SENSOR_WORD_WRITE,  0x099A, 0x0BAD} ,
{SENSOR_WORD_WRITE,  0x099C, 0x0232} ,
{SENSOR_WORD_WRITE,  0x099E, 0xC26E} ,

{SENSOR_WORD_WRITE,  0x098A, 0x1600} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x8974} ,
{SENSOR_WORD_WRITE,  0x0992, 0x4C2F} ,
{SENSOR_WORD_WRITE,  0x0994, 0xB56E} ,
{SENSOR_WORD_WRITE,  0x0996, 0x0070} ,
{SENSOR_WORD_WRITE,  0x0998, 0x04D1} ,
{SENSOR_WORD_WRITE,  0x099A, 0xB313} ,
{SENSOR_WORD_WRITE,  0x099C, 0xCF8F} ,
{SENSOR_WORD_WRITE,  0x099E, 0xB0AE} ,

{SENSOR_WORD_WRITE,  0x098A, 0x1610} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x4CF1} ,
{SENSOR_WORD_WRITE,  0x0992, 0x1150} ,
{SENSOR_WORD_WRITE,  0x0994, 0x8373} ,
{SENSOR_WORD_WRITE,  0x0996, 0xAE2E} ,
{SENSOR_WORD_WRITE,  0x0998, 0x0DED} ,
{SENSOR_WORD_WRITE,  0x099A, 0x1AD1} ,
{SENSOR_WORD_WRITE,  0x099C, 0x9028} ,
{SENSOR_WORD_WRITE,  0x099E, 0x8EF3} ,

{SENSOR_WORD_WRITE,  0x098A, 0x1620} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x82B1} ,
{SENSOR_WORD_WRITE,  0x0992, 0xBB6E} ,
{SENSOR_WORD_WRITE,  0x0994, 0x9E54} ,
{SENSOR_WORD_WRITE,  0x0996, 0xD830} ,
{SENSOR_WORD_WRITE,  0x0998, 0x08B7} ,
{SENSOR_WORD_WRITE,  0x099A, 0x9D31} ,
{SENSOR_WORD_WRITE,  0x099C, 0x4930} ,
{SENSOR_WORD_WRITE,  0x099E, 0x8FF4} ,

{SENSOR_WORD_WRITE,  0x098A, 0x1630} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0xC592} ,
{SENSOR_WORD_WRITE,  0x0992, 0x0557} ,
{SENSOR_WORD_WRITE,  0x0994, 0x8451} ,
{SENSOR_WORD_WRITE,  0x0996, 0xD54D} ,
{SENSOR_WORD_WRITE,  0x0998, 0x9513} ,
{SENSOR_WORD_WRITE,  0x099A, 0xE8D1} ,
{SENSOR_WORD_WRITE,  0x099C, 0x4676} ,
{SENSOR_WORD_WRITE,  0x099E, 0xC8F0} ,

{SENSOR_WORD_WRITE,  0x098A, 0x1640} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990, 0x43F1} ,
{SENSOR_WORD_WRITE,  0x0992, 0xD8D4} ,
{SENSOR_WORD_WRITE,  0x0994, 0xBF73} ,
{SENSOR_WORD_WRITE,  0x0996, 0x1CB7} ,
{SENSOR_WORD_WRITE,  0x0998, 0x03DC} ,
{SENSOR_WORD_WRITE,  0x099A, 0x04F4} ,
{SENSOR_WORD_WRITE,  0x099C, 0x0000} ,
{SENSOR_WORD_WRITE,  0x099E, 0x0000} ,


//APGA patch RAM LSC, Zone 1, CWF or TL84, start address is 0x164C (5708)
//REG= 0x0982,	0x0000} ,	// ACCESS_CTL_STAT
{SENSOR_WORD_WRITE,  0x098A,	0x164C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x7B2F} ,
{SENSOR_WORD_WRITE,  0x0992,	0x6CC9} ,
{SENSOR_WORD_WRITE,  0x0994,	0x37F1} ,
{SENSOR_WORD_WRITE,  0x0996,	0x738D} ,
{SENSOR_WORD_WRITE,  0x0998,	0xF210} ,
{SENSOR_WORD_WRITE,  0x099A,	0x0110} ,
{SENSOR_WORD_WRITE,  0x099C,	0xBF0E} ,
{SENSOR_WORD_WRITE,  0x099E,	0x1F71} ,

{SENSOR_WORD_WRITE,  0x098A,	0x165C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x2BEF} ,
{SENSOR_WORD_WRITE,  0x0992,	0xDD10} ,
{SENSOR_WORD_WRITE,  0x0994,	0x7E8F} ,
{SENSOR_WORD_WRITE,  0x0996,	0x1F2B} ,
{SENSOR_WORD_WRITE,  0x0998,	0x5EB0} ,
{SENSOR_WORD_WRITE,  0x099A,	0xF76B} ,
{SENSOR_WORD_WRITE,  0x099C,	0x93D0} ,
{SENSOR_WORD_WRITE,  0x099E,	0x7CAF} ,

{SENSOR_WORD_WRITE,  0x098A,	0x166C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0xCEAE} ,
{SENSOR_WORD_WRITE,  0x0992,	0x3A51} ,
{SENSOR_WORD_WRITE,  0x0994,	0x108E} ,
{SENSOR_WORD_WRITE,  0x0996,	0xD530} ,
{SENSOR_WORD_WRITE,  0x0998,	0x876C} ,
{SENSOR_WORD_WRITE,  0x099A,	0x9BEE} ,
{SENSOR_WORD_WRITE,  0x099C,	0xB0AF} ,
{SENSOR_WORD_WRITE,  0x099E,	0x4E6C} ,

{SENSOR_WORD_WRITE,  0x098A,	0x167C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x2051} ,
{SENSOR_WORD_WRITE,  0x0992,	0x70CC} ,
{SENSOR_WORD_WRITE,  0x0994,	0x082E} ,
{SENSOR_WORD_WRITE,  0x0996,	0xB828} ,
{SENSOR_WORD_WRITE,  0x0998,	0xC9EF} ,
{SENSOR_WORD_WRITE,  0x099A,	0x10D0} ,
{SENSOR_WORD_WRITE,  0x099C,	0x844C} ,
{SENSOR_WORD_WRITE,  0x099E,	0x540D} ,

{SENSOR_WORD_WRITE,  0x098A,	0x168C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x46CE} ,
{SENSOR_WORD_WRITE,  0x0992,	0x86AF} ,
{SENSOR_WORD_WRITE,  0x0994,	0xD70C} ,
{SENSOR_WORD_WRITE,  0x0996,	0x762B} ,
{SENSOR_WORD_WRITE,  0x0998,	0xF06E} ,
{SENSOR_WORD_WRITE,  0x099A,	0x37EE} ,
{SENSOR_WORD_WRITE,  0x099C,	0x5FEE} ,
{SENSOR_WORD_WRITE,  0x099E,	0xB06B} ,

{SENSOR_WORD_WRITE,  0x098A,	0x169C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x75F1} ,
{SENSOR_WORD_WRITE,  0x0992,	0x6C4F} ,
{SENSOR_WORD_WRITE,  0x0994,	0x84F3} ,
{SENSOR_WORD_WRITE,  0x0996,	0xE0AF} ,
{SENSOR_WORD_WRITE,  0x0998,	0x5A93} ,
{SENSOR_WORD_WRITE,  0x099A,	0x55D1} ,
{SENSOR_WORD_WRITE,  0x099C,	0x79ED} ,
{SENSOR_WORD_WRITE,  0x099E,	0xD772} ,

{SENSOR_WORD_WRITE,  0x098A,	0x16AC} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0xAE50} ,
{SENSOR_WORD_WRITE,  0x0992,	0x50F3} ,
{SENSOR_WORD_WRITE,  0x0994,	0x5591} ,
{SENSOR_WORD_WRITE,  0x0996,	0x1D90} ,
{SENSOR_WORD_WRITE,  0x0998,	0x8593} ,
{SENSOR_WORD_WRITE,  0x099A,	0xF0F0} ,
{SENSOR_WORD_WRITE,  0x099C,	0x7733} ,
{SENSOR_WORD_WRITE,  0x099E,	0x7211} ,

{SENSOR_WORD_WRITE,  0x098A,	0x16BC} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x994F} ,
{SENSOR_WORD_WRITE,  0x0992,	0xADF2} ,
{SENSOR_WORD_WRITE,  0x0994,	0x0611} ,
{SENSOR_WORD_WRITE,  0x0996,	0x27B2} ,
{SENSOR_WORD_WRITE,  0x0998,	0x6A4C} ,
{SENSOR_WORD_WRITE,  0x099A,	0xB52D} ,
{SENSOR_WORD_WRITE,  0x099C,	0x1FD2} ,
{SENSOR_WORD_WRITE,  0x099E,	0x6530} ,

{SENSOR_WORD_WRITE,  0x098A,	0x16CC} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x9B54} ,
{SENSOR_WORD_WRITE,  0x0992,	0x33EF} ,
{SENSOR_WORD_WRITE,  0x0994,	0xC96F} ,
{SENSOR_WORD_WRITE,  0x0996,	0x5DB0} ,
{SENSOR_WORD_WRITE,  0x0998,	0x0C12} ,
{SENSOR_WORD_WRITE,  0x099A,	0xB0B3} ,
{SENSOR_WORD_WRITE,  0x099C,	0xB58F} ,
{SENSOR_WORD_WRITE,  0x099E,	0xE88F} ,

{SENSOR_WORD_WRITE,  0x098A,	0x16DC} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x3B11} ,
{SENSOR_WORD_WRITE,  0x0992,	0x4871} ,
{SENSOR_WORD_WRITE,  0x0994,	0x80B3} ,
{SENSOR_WORD_WRITE,  0x0996,	0xAE6D} ,
{SENSOR_WORD_WRITE,  0x0998,	0x47CB} ,
{SENSOR_WORD_WRITE,  0x099A,	0x43F0} ,
{SENSOR_WORD_WRITE,  0x099C,	0x7FEE} ,
{SENSOR_WORD_WRITE,  0x099E,	0xDF32} ,

{SENSOR_WORD_WRITE,  0x098A,	0x16EC} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x8F11} ,
{SENSOR_WORD_WRITE,  0x0992,	0x13CF} ,
{SENSOR_WORD_WRITE,  0x0994,	0xEDF3} ,
{SENSOR_WORD_WRITE,  0x0996,	0xE333} ,
{SENSOR_WORD_WRITE,  0x0998,	0x7DB6} ,
{SENSOR_WORD_WRITE,  0x099A,	0x8F11} ,
{SENSOR_WORD_WRITE,  0x099C,	0x2AD0} ,
{SENSOR_WORD_WRITE,  0x099E,	0xE0B2} ,

{SENSOR_WORD_WRITE,  0x098A,	0x16FC} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x80F4} ,
{SENSOR_WORD_WRITE,  0x0992,	0x4AB6} ,
{SENSOR_WORD_WRITE,  0x0994,	0xD231} ,
{SENSOR_WORD_WRITE,  0x0996,	0xA270} ,
{SENSOR_WORD_WRITE,  0x0998,	0x4D4F} ,
{SENSOR_WORD_WRITE,  0x099A,	0x8533} ,
{SENSOR_WORD_WRITE,  0x099C,	0x2836} ,
{SENSOR_WORD_WRITE,  0x099E,	0xDDD0} ,

{SENSOR_WORD_WRITE,  0x098A,	0x170C} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x1792} ,
{SENSOR_WORD_WRITE,  0x0992,	0xCF14} ,
{SENSOR_WORD_WRITE,  0x0994,	0xF794} ,
{SENSOR_WORD_WRITE,  0x0996,	0x20B7} ,
{SENSOR_WORD_WRITE,  0x0998,	0x03DC} ,
{SENSOR_WORD_WRITE,  0x099A,	0x04B8} ,
{SENSOR_WORD_WRITE,  0x099C,	0x0000} ,
{SENSOR_WORD_WRITE,  0x099E,	0x0000} ,


//APGA patch RAM LSC, Zone 2, D65 or DNP, start address is 0x1718 (5912)
//REG= 0x0982,	0x0000} ,	// ACCESS_CTL_STAT
{SENSOR_WORD_WRITE,  0x098A,	0x1718} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x0090} ,
{SENSOR_WORD_WRITE,  0x0992,	0x352C} ,
{SENSOR_WORD_WRITE,  0x0994,	0x5871} ,
{SENSOR_WORD_WRITE,  0x0996,	0x480D} ,
{SENSOR_WORD_WRITE,  0x0998,	0x8911} ,
{SENSOR_WORD_WRITE,  0x099A,	0x0030} ,
{SENSOR_WORD_WRITE,  0x099C,	0x956E} ,
{SENSOR_WORD_WRITE,  0x099E,	0x2BF1} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1728} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x03EF} ,
{SENSOR_WORD_WRITE,  0x0992,	0xFF70} ,
{SENSOR_WORD_WRITE,  0x0994,	0x7D0F} ,
{SENSOR_WORD_WRITE,  0x0996,	0x330C} ,
{SENSOR_WORD_WRITE,  0x0998,	0x1831} ,
{SENSOR_WORD_WRITE,  0x099A,	0x070C} ,
{SENSOR_WORD_WRITE,  0x099C,	0xCBF0} ,
{SENSOR_WORD_WRITE,  0x099E,	0x7D8F} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1738} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0xAC0E} ,
{SENSOR_WORD_WRITE,  0x0992,	0x4D71} ,
{SENSOR_WORD_WRITE,  0x0994,	0x0FCD} ,
{SENSOR_WORD_WRITE,  0x0996,	0x8011} ,
{SENSOR_WORD_WRITE,  0x0998,	0xBFCB} ,
{SENSOR_WORD_WRITE,  0x099A,	0xE38E} ,
{SENSOR_WORD_WRITE,  0x099C,	0x86B0} ,
{SENSOR_WORD_WRITE,  0x099E,	0x744E} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1748} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x4FB1} ,
{SENSOR_WORD_WRITE,  0x0992,	0x3EAD} ,
{SENSOR_WORD_WRITE,  0x0994,	0x540D} ,
{SENSOR_WORD_WRITE,  0x0996,	0x942C} ,
{SENSOR_WORD_WRITE,  0x0998,	0x892F} ,
{SENSOR_WORD_WRITE,  0x099A,	0x0950} ,
{SENSOR_WORD_WRITE,  0x099C,	0x038C} ,
{SENSOR_WORD_WRITE,  0x099E,	0x2D8E} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1758} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x75AE} ,
{SENSOR_WORD_WRITE,  0x0992,	0xF54E} ,
{SENSOR_WORD_WRITE,  0x0994,	0xEDCE} ,
{SENSOR_WORD_WRITE,  0x0996,	0x090D} ,
{SENSOR_WORD_WRITE,  0x0998,	0x868F} ,
{SENSOR_WORD_WRITE,  0x099A,	0x70ED} ,
{SENSOR_WORD_WRITE,  0x099C,	0x2E8F} ,
{SENSOR_WORD_WRITE,  0x099E,	0x7D2B} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1768} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x01F2} ,
{SENSOR_WORD_WRITE,  0x0992,	0x3E6F} ,
{SENSOR_WORD_WRITE,  0x0994,	0xEFB2} ,
{SENSOR_WORD_WRITE,  0x0996,	0xF98E} ,
{SENSOR_WORD_WRITE,  0x0998,	0x2B13} ,
{SENSOR_WORD_WRITE,  0x099A,	0x61D1} ,
{SENSOR_WORD_WRITE,  0x099C,	0x894E} ,
{SENSOR_WORD_WRITE,  0x099E,	0xDD92} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1778} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0xC60B} ,
{SENSOR_WORD_WRITE,  0x0992,	0x5153} ,
{SENSOR_WORD_WRITE,  0x0994,	0x6231} ,
{SENSOR_WORD_WRITE,  0x0996,	0x7A2F} ,
{SENSOR_WORD_WRITE,  0x0998,	0xB552} ,
{SENSOR_WORD_WRITE,  0x099A,	0x73AC} ,
{SENSOR_WORD_WRITE,  0x099C,	0x07B3} ,
{SENSOR_WORD_WRITE,  0x099E,	0x0AF2} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1788} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x93B0} ,
{SENSOR_WORD_WRITE,  0x0992,	0xC432} ,
{SENSOR_WORD_WRITE,  0x0994,	0x5ED1} ,
{SENSOR_WORD_WRITE,  0x0996,	0x43D2} ,
{SENSOR_WORD_WRITE,  0x0998,	0x284D} ,
{SENSOR_WORD_WRITE,  0x099A,	0x6C4E} ,
{SENSOR_WORD_WRITE,  0x099C,	0x1032} ,
{SENSOR_WORD_WRITE,  0x099E,	0xA82F} ,

{SENSOR_WORD_WRITE,  0x098A,	0x1798} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0xF9B3} ,
{SENSOR_WORD_WRITE,  0x0992,	0x2A4F} ,
{SENSOR_WORD_WRITE,  0x0994,	0xDE8C} ,
{SENSOR_WORD_WRITE,  0x0996,	0xE2AB} ,
{SENSOR_WORD_WRITE,  0x0998,	0x5AB0} ,
{SENSOR_WORD_WRITE,  0x099A,	0xDE31} ,
{SENSOR_WORD_WRITE,  0x099C,	0x928F} ,
{SENSOR_WORD_WRITE,  0x099E,	0x86CF} ,

{SENSOR_WORD_WRITE,  0x098A,	0x17A8} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x52AD} ,
{SENSOR_WORD_WRITE,  0x0992,	0x640F} ,
{SENSOR_WORD_WRITE,  0x0994,	0x0891} ,
{SENSOR_WORD_WRITE,  0x0996,	0x9D2E} ,
{SENSOR_WORD_WRITE,  0x0998,	0x2E6E} ,
{SENSOR_WORD_WRITE,  0x099A,	0x3A6E} ,
{SENSOR_WORD_WRITE,  0x099C,	0x83AF} ,
{SENSOR_WORD_WRITE,  0x099E,	0x9CCF} ,

{SENSOR_WORD_WRITE,  0x098A,	0x17B8} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x8131} ,
{SENSOR_WORD_WRITE,  0x0992,	0xED0D} ,
{SENSOR_WORD_WRITE,  0x0994,	0xA194} ,
{SENSOR_WORD_WRITE,  0x0996,	0x9932} ,
{SENSOR_WORD_WRITE,  0x0998,	0x06D7} ,
{SENSOR_WORD_WRITE,  0x099A,	0xF890} ,
{SENSOR_WORD_WRITE,  0x099C,	0x6670} ,
{SENSOR_WORD_WRITE,  0x099E,	0xBDD3} ,

{SENSOR_WORD_WRITE,  0x098A,	0x17C8} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x8F93} ,
{SENSOR_WORD_WRITE,  0x0992,	0x5396} ,
{SENSOR_WORD_WRITE,  0x0994,	0xE2F0} ,
{SENSOR_WORD_WRITE,  0x0996,	0xB2CC} ,
{SENSOR_WORD_WRITE,  0x0998,	0x96F4} ,
{SENSOR_WORD_WRITE,  0x099A,	0xA453} ,
{SENSOR_WORD_WRITE,  0x099C,	0x7B16} ,
{SENSOR_WORD_WRITE,  0x099E,	0xD670} ,

{SENSOR_WORD_WRITE,  0x098A,	0x17D8} ,	// Patch RAM Address
{SENSOR_WORD_WRITE,  0x0990,	0x0D72} ,
{SENSOR_WORD_WRITE,  0x0992,	0xE194} ,
{SENSOR_WORD_WRITE,  0x0994,	0x9DD4} ,
{SENSOR_WORD_WRITE,  0x0996,	0x1CD7} ,
{SENSOR_WORD_WRITE,  0x0998,	0x03F0} ,
{SENSOR_WORD_WRITE,  0x099A,	0x04E0} ,
{SENSOR_WORD_WRITE,  0x099C,	0x0000} ,
{SENSOR_WORD_WRITE,  0x099E,	0x0000} ,

// end of Rev2.
//;[Load PGA settings from Patch RAM with APGA function enabled]
// for using 3 PGA settings for all CT conditions
// enalbe PGA setting
{SENSOR_WORD_WRITE,  0x098E, 0x1000} ,	// LOGICAL_ADDRESS_ACCESS [PGA_SOLUTION]
{SENSOR_BYTE_WRITE,  0xD004, 0x02} ,	// PGA_SOLUTION
{SENSOR_WORD_WRITE,  0xD006, 0x1580} ,	// PGA_ZONE_ADDR_0 -- this is the address of PGA Zone 0
{SENSOR_WORD_WRITE,  0xD008, 0x164C} ,	// PGA_ZONE_ADDR_1 -- this is the address of PGA Zone 1
{SENSOR_WORD_WRITE,  0xD00A, 0x1718} ,	// PGA_ZONE_ADDR_2 -- this is the address of PGA Zone 2
{SENSOR_BYTE_WRITE,  0xD005, 0x00} ,	// PGA_CURRENT_ZONE -- Specify PGA Zone to 0~2
{SENSOR_WORD_WRITE,  0xD002, 0x8007} ,	// PGA_ALGO

// set up APGA parameter according to the AWB result
{SENSOR_BYTE_WRITE,  0xD00C,	0x03} ,	// PGA_NO_OF_ZONES

// below settings is used for APGA and related to "AWB_CURRENT_CCM_POSITION"
// User may need to fine tune according to the AWB parameter settings
{SENSOR_BYTE_WRITE,  0xD00D, 0x00} ,	// PGA_ZONE_LOW_0 -- low limit for low CT condition, i.e. A-light
// -- Rev1, 02232011, Alias
// modified APGA zone according to new lens and IRCF
{SENSOR_BYTE_WRITE,  0xD00E, 0x15} ,	// PGA_ZONE_LOW_1 -- low limit for middle CT condition, i.e. CWF or TL84
{SENSOR_BYTE_WRITE,  0xD00F, 0x6F} ,	// PGA_ZONE_LOW_2 -- low limit for higher CT condition, i.e. D65 or DNP
// -- Rev1, 02232011, Alias
// modified APGA zone according to new lens and IRCF
{SENSOR_BYTE_WRITE,  0xD011, 0x14} ,	// PGA_ZONE_HIGH_0 -- high limit for low CT condition, i.e. A-light
{SENSOR_BYTE_WRITE,  0xD012, 0x6E} ,	// PGA_ZONE_HIGH_1 -- high limit for middle CT condition, i.e. CWF or TL84
{SENSOR_BYTE_WRITE,  0xD013, 0x7F} ,	// PGA_ZONE_HIGH_2 -- high limit for higher CT condition, i.e. D65 or DNP



//;**********************************************************************************************************
//; [Section5]	} ,	// AWB and CCM
//;**********************************************************************************************************

// AWB and CCM
//;[Section5-Pre AWB settings]
{SENSOR_WORD_WRITE,  0x098E, 0x2C02} ,  	// LOGICAL_ADDRESS_ACCESS [AWB_ALGO]
{SENSOR_WORD_WRITE,  0xAC02, 0x00FF} ,  	// AWB_ALGO
{SENSOR_BYTE_WRITE,  0xAC01, 0xAB} ,  	// AWB_MODE
{SENSOR_BYTE_WRITE,  0xAC3C, 0x39} ,  	// AWB_MIN_ACCEPTED_PRE_AWB_R2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC3D, 0x6E} ,  	// AWB_MAX_ACCEPTED_PRE_AWB_R2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC3E, 0x28} ,  	// AWB_MIN_ACCEPTED_PRE_AWB_B2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC3F, 0x6B} ,  	// AWB_MAX_ACCEPTED_PRE_AWB_B2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC40, 0x64} ,  	// AWB_MIN_ACCEPTED_POST_AWB_R2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC41, 0x66} ,  	// AWB_MAX_ACCEPTED_POST_AWB_R2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC42, 0x64} ,  	// AWB_MIN_ACCEPTED_POST_AWB_B2G_RATIO
{SENSOR_BYTE_WRITE,  0xAC43, 0x66} ,  	// AWB_MAX_ACCEPTED_POST_AWB_B2G_RATIO
{SENSOR_BYTE_WRITE,  0xACB0, 0x31} ,  	// AWB_RG_MIN
{SENSOR_BYTE_WRITE,  0xACB1, 0x5F} ,	//0x5B} ,  	// AWB_RG_MAX
{SENSOR_BYTE_WRITE,  0xACB4, 0x22} ,	//0x2A} ,  	// AWB_BG_MIN
{SENSOR_BYTE_WRITE,  0xACB5, 0x5B} ,  	// AWB_BG_MAX

// -- Rev1, 02232011, Alias
// modified Pre-AWB setting, fix AWB failed when ponit camera to A Light
{SENSOR_BYTE_WRITE,  0xACB2, 0x41 } ,  	// AWB_RG_MIN_BRIGHT} ,  	//0x41
{SENSOR_BYTE_WRITE,  0xACB3, 0x43 } ,  	// AWB_RG_MAX_BRIGHT 	} ,	//0x43
{SENSOR_BYTE_WRITE,  0xACB6, 0x4E } ,  	// AWB_BG_MIN_BRIGHT} ,  	//0x4E
{SENSOR_BYTE_WRITE,  0xACB7, 0x50 } ,  	// AWB_BG_MAX_BRIGHT 	} ,	//0x50
{SENSOR_WORD_WRITE,  0xACB8, 0x0032} ,	// AWB_START_NUM_INT_LINES} ,	//0x0032
{SENSOR_WORD_WRITE,  0xACBA, 0x000A} ,	// AWB_END_NUM_INT_LINES        //0x000A
{SENSOR_BYTE_WRITE,  0xAC09, 0x01} ,  	// AWB_UNUSED1
{SENSOR_WORD_WRITE,  0xAC22, 0x0000} ,  	// AWB_UNUSED2
// CCM
{SENSOR_WORD_WRITE,  0xAC46, 0x0235} ,  	// AWB_LEFT_CCM_0
{SENSOR_WORD_WRITE,  0xAC48, 0xFE7C} ,  	// AWB_LEFT_CCM_1
{SENSOR_WORD_WRITE,  0xAC4A, 0xFFEC} ,  	// AWB_LEFT_CCM_2
{SENSOR_WORD_WRITE,  0xAC4C, 0xFFBB} ,  	// AWB_LEFT_CCM_3
{SENSOR_WORD_WRITE,  0xAC4E, 0x0196} ,  	// AWB_LEFT_CCM_4
{SENSOR_WORD_WRITE,  0xAC50, 0xFFB0} ,  	// AWB_LEFT_CCM_5
{SENSOR_WORD_WRITE,  0xAC52, 0xFFEC} ,  	// AWB_LEFT_CCM_6
{SENSOR_WORD_WRITE,  0xAC54, 0xFE92} ,  	// AWB_LEFT_CCM_7
{SENSOR_WORD_WRITE,  0xAC56, 0x0282} ,  	// AWB_LEFT_CCM_8
{SENSOR_WORD_WRITE,  0xAC58, 0x00C6} ,  	// AWB_LEFT_CCM_R2BRATIO
// -- Rev1, 02232011, Alias
// modified CCM table for D65
{SENSOR_WORD_WRITE,  0xAC5C, 0x01CE} ,  	// AWB_RIGHT_CCM_0
{SENSOR_WORD_WRITE,  0xAC5E, 0xFEB9} ,  	// AWB_RIGHT_CCM_1
{SENSOR_WORD_WRITE,  0xAC60, 0x0015} ,  	// AWB_RIGHT_CCM_2
{SENSOR_WORD_WRITE,  0xAC62, 0xFF9A} ,  	// AWB_RIGHT_CCM_3
{SENSOR_WORD_WRITE,  0xAC64, 0x019E} ,  	// AWB_RIGHT_CCM_4
{SENSOR_WORD_WRITE,  0xAC66, 0xFFC8} ,  	// AWB_RIGHT_CCM_5
{SENSOR_WORD_WRITE,  0xAC68, 0x000B} ,  	// AWB_RIGHT_CCM_6
{SENSOR_WORD_WRITE,  0xAC6A, 0xFF0B} ,  	// AWB_RIGHT_CCM_7
{SENSOR_WORD_WRITE,  0xAC6C, 0x0213} ,  	// AWB_RIGHT_CCM_8
{SENSOR_WORD_WRITE,  0xAC6E, 0x0069} ,  	// AWB_RIGHT_CCM_R2BRATIO
{SENSOR_BYTE_WRITE,  0xAC97, 0x73} ,  	// AWB_LEFT_TINT_COEF_FOR_CCM_ROW_0
{SENSOR_BYTE_WRITE,  0xAC99, 0x8A} ,  	// AWB_LEFT_TINT_COEF_FOR_CCM_ROW_2
{SENSOR_BYTE_WRITE,  0xB83E, 0x00} ,  	// STAT_AWB_WINDOW_POS_X
{SENSOR_BYTE_WRITE,  0xB83F, 0x00} ,  	// STAT_AWB_WINDOW_POS_Y
{SENSOR_BYTE_WRITE,  0xB840, 0xFF} ,  	// STAT_AWB_WINDOW_SIZE_X
{SENSOR_BYTE_WRITE,  0xB841, 0xEF} ,  	// STAT_AWB_WINDOW_SIZE_Y
{SENSOR_BYTE_WRITE,  0x8404, 0x05} ,  	// SEQ_CMD

// -- Rev1, 02232011, Alias
// modified gray checker offset
//;REG= 0xB842, 0x003D} ,  	// STAT_AWB_GRAY_CHECKER_OFFSET_X
//;REG= 0xB844, 0x0038} ,  	// STAT_AWB_GRAY_CHECKER_OFFSET_Y
{SENSOR_WORD_WRITE,  0xB842, 0x003C} ,  	// STAT_AWB_GRAY_CHECKER_OFFSET_X
{SENSOR_WORD_WRITE,  0xB844, 0x0041} ,  	// STAT_AWB_GRAY_CHECKER_OFFSET_Y
// -- Rev1, 02232011, Alias
// modified gray checker scale
//;REG= 0x3240, 0x0023} ,  	// AWB_XY_SCALE
{SENSOR_WORD_WRITE,  0x3240, 0x0024} ,  	// AWB_XY_SCALE
{SENSOR_WORD_WRITE,  0x3242, 0x0000} ,  	// AWB_WEIGHT_R0
{SENSOR_WORD_WRITE,  0x3244, 0x1550} ,  	// AWB_WEIGHT_R1
{SENSOR_WORD_WRITE,  0x3246, 0x1F00} ,  	// AWB_WEIGHT_R2
{SENSOR_WORD_WRITE,  0x3248, 0x7380} ,  	// AWB_WEIGHT_R3
{SENSOR_WORD_WRITE,  0x324A, 0x70E0} ,  	// AWB_WEIGHT_R4
{SENSOR_WORD_WRITE,  0x324C, 0x01F0} ,  	// AWB_WEIGHT_R5
{SENSOR_WORD_WRITE,  0x324E, 0x006B} ,  	// AWB_WEIGHT_R6
{SENSOR_WORD_WRITE,  0x3250, 0x0055} ,  	// AWB_WEIGHT_R7

// -- Rev1, 02232011, Alias
// removed "Gray World AWB settings
//;;[Gray World AWB settings-a]
//;REG= 0x098E, 0x3842} ,  	// LOGICAL_ADDRESS_ACCESS [STAT_AWB_GRAY_CHECKER_OFFSET_X]
//;REG= 0xB842, 0x0118} ,  	// STAT_AWB_GRAY_CHECKER_OFFSET_X
//;REG= 0xB844, 0x0091} ,  	// STAT_AWB_GRAY_CHECKER_OFFSET_Y
//;REG= 0x3240, 0x0020} ,  	// AWB_XY_SCALE
//;REG= 0x3240, 0x0000} ,  	// AWB_XY_SCALE
//;REG= 0x3242, 0x1008} ,  	// AWB_WEIGHT_R0
//;REG= 0x3244, 0x1008} ,  	// AWB_WEIGHT_R1
//;REG= 0x3246, 0x1008} ,  	// AWB_WEIGHT_R2
//;REG= 0x3248, 0x1008} ,  	// AWB_WEIGHT_R3
//;REG= 0x324A, 0x1008} ,  	// AWB_WEIGHT_R4
//;REG= 0x324C, 0x1008} ,  	// AWB_WEIGHT_R5
//;REG= 0x324E, 0x1008} ,  	// AWB_WEIGHT_R6
//;REG= 0x3250, 0x1008} ,  	// AWB_WEIGHT_R7

//[Weight table_ASUS_7Feb]
//;REG= 0x3242, 0x0000} ,  	// AWB_WEIGHT_R0
//;REG= 0x3244, 0x0000} ,  	// AWB_WEIGHT_R1
//;REG= 0x3246, 0x0000} ,  	// AWB_WEIGHT_R2
//;REG= 0x3248, 0x7F00} ,  	// AWB_WEIGHT_R3
//;REG= 0x324A, 0xA5F0} ,  	// AWB_WEIGHT_R4
//;REG= 0x324C, 0x1540} ,  	// AWB_WEIGHT_R5
//;REG= 0x324E, 0x01AC} ,  	// AWB_WEIGHT_R6
//;REG= 0x3250, 0x003E} ,  	// AWB_WEIGHT_R7

{SENSOR_WORD_WRITE,  0x098E, 0xAC0E} ,  	// LOGICAL_ADDRESS_ACCESS [AWB_CCM_SATURATION]
// -- Rev1, 02232011, Alias
// removed CCM saturation from here
//;REG= 0xBC56, 0xE7} ,  	// LL_Start_ccm_sat
//;REG= 0xAC0E, 0xE7} ,  	// AWB_CCM_SATURATION
{SENSOR_BYTE_WRITE,  0x8404, 0x05} ,  	// SEQ_CMD



//;**********************************************************************************************************
//;[Section6]	} ,	// PA Calib
//;**********************************************************************************************************
//; [section6]	} ,	//PA Calib
//;[Sys_Settings]
{SENSOR_WORD_WRITE,  0x301A, 0x10F4} ,  	// RESET_REGISTER
{SENSOR_WORD_WRITE,  0x301E, 0x0083} ,  	// DATA_PEDESTAL
{SENSOR_WORD_WRITE,  0x301A, 0x10FC} ,  	// RESET_REGISTER
{SENSOR_BYTE_WRITE,  0xDC33, 0x20} ,  	// SYS_FIRST_BLACK_LEVEL
{SENSOR_BYTE_WRITE,  0xDC35, 0x04} ,  	// SYS_UV_COLOR_BOOST
{SENSOR_WORD_WRITE,  0x326E, 0x0006} ,  	// LOW_PASS_YUV_FILTER
{SENSOR_BYTE_WRITE,  0xDC37, 0x62} ,  	// SYS_BRIGHT_COLORKILL
{SENSOR_WORD_WRITE,  0x35A4, 0x0596} ,  	// BRIGHT_COLOR_KILL_CONTROLS
{SENSOR_WORD_WRITE,  0x35A2, 0x009C} ,  	// DARK_COLOR_KILL_CONTROLS
{SENSOR_WORD_WRITE,  0xDC02, 0x003E} ,  	// SYS_ALGO
{SENSOR_BYTE_WRITE,  0xDC36, 0x34} ,  	// SYS_DARK_COLOR_KILL

//;[AE settings]
{SENSOR_BYTE_WRITE,  0xB827, 0x0F} ,  	// STAT_AE_EV_SHIFT //Rev2a
{SENSOR_BYTE_WRITE,  0xB820, 0x26} ,  	// STAT_AE_WINDOW_POS_X
{SENSOR_BYTE_WRITE,  0xB821, 0x26} ,  	// STAT_AE_WINDOW_POS_Y
{SENSOR_BYTE_WRITE,  0xB822, 0xB5} ,  	// STAT_AE_WINDOW_SIZE_X
{SENSOR_BYTE_WRITE,  0xB823, 0xB5} ,  	// STAT_AE_WINDOW_SIZE_Y
{SENSOR_WORD_WRITE,  0xA802, 0x0007} ,  	// AE_TRACK_ALGO
{SENSOR_BYTE_WRITE,  0xA80E, 0x08} ,  	// AE_TRACK_MAX_BLACK_LEVEL
{SENSOR_BYTE_WRITE,  0xA409, 0x44} ,	//0x44} ,  	// AE_RULE_BASE_TARGET //Rev2a
// -- Rev2, 03092011, Alias
// modified for AE -- over exposure in outdoor
{SENSOR_BYTE_WRITE,  0xA805, 0x04} ,  	// AE_TRACK_GATE
{SENSOR_BYTE_WRITE,  0xA401, 0x0C} ,  	// AE_RULE_MODE
{SENSOR_WORD_WRITE,  0xA818, 0x0298} ,  // AE_TRACK_TARGET_INT_TIME_ROWS
{SENSOR_BYTE_WRITE,  0x840E, 0x02} ,    // SEQ_STATE_CFG_0_AE  //Rev2a
{SENSOR_BYTE_WRITE,  0x8416, 0x02} ,    // SEQ_STATE_CFG_1_AE  //Rev2a
{SENSOR_BYTE_WRITE,  0x841E, 0x02} ,  // SEQ_STATE_CFG_2_AE  //Rev2a
// end 0f Rev2.
//
{SENSOR_WORD_WRITE,  0xBC52, 0x00C8} ,  	// LL_START_BRIGHTNESS_METRIC
{SENSOR_WORD_WRITE,  0xBC54, 0x03E8} ,  	// LL_END_BRIGHTNESS_METRIC
{SENSOR_WORD_WRITE,  0xBC58, 0x00C8} ,  	// LL_START_GAIN_METRIC
{SENSOR_WORD_WRITE,  0xBC5A, 0x0728} ,  	// LL_END_GAIN_METRIC
{SENSOR_WORD_WRITE,  0xBC5E, 0x00FA} ,  	// LL_START_APERTURE_GAIN_BM
{SENSOR_WORD_WRITE,  0xBC60, 0x028A} ,  	// LL_END_APERTURE_GAIN_BM
{SENSOR_WORD_WRITE,  0xBC66, 0x00FA} ,  	// LL_START_APERTURE_GM
{SENSOR_WORD_WRITE,  0xBC68, 0x028A} ,  	// LL_END_APERTURE_GM
{SENSOR_WORD_WRITE,  0xBC86, 0x00C8} ,  	// LL_START_FFNR_GM
{SENSOR_WORD_WRITE,  0xBC88, 0x028A} ,  	// LL_END_FFNR_GM
{SENSOR_WORD_WRITE,  0xBCBC, 0x0040} ,  	// LL_SFFB_START_GAIN
{SENSOR_WORD_WRITE,  0xBCBE, 0x01FC} ,  	// LL_SFFB_END_GAIN
{SENSOR_WORD_WRITE,  0xBCCC, 0x00C8} ,  	// LL_SFFB_START_MAX_GM
{SENSOR_WORD_WRITE,  0xBCCE, 0x028A} ,  	// LL_SFFB_END_MAX_GM
{SENSOR_WORD_WRITE,  0xBC90, 0x00C8} ,  	// LL_START_GRB_GM
{SENSOR_WORD_WRITE,  0xBC92, 0x028A} ,  	// LL_END_GRB_GM
{SENSOR_WORD_WRITE,  0xBC0E, 0x0001} ,  	// LL_GAMMA_CURVE_ADJ_START_POS
{SENSOR_WORD_WRITE,  0xBC10, 0x00F0} ,  	// LL_GAMMA_CURVE_ADJ_MID_POS
{SENSOR_WORD_WRITE,  0xBC12, 0x0640} ,  	// LL_GAMMA_CURVE_ADJ_END_POS
{SENSOR_WORD_WRITE,  0xBCAA, 0x044C} ,  	// LL_CDC_THR_ADJ_START_POS
{SENSOR_WORD_WRITE,  0xBCAC, 0x00AF} ,  	// LL_CDC_THR_ADJ_MID_POS
{SENSOR_WORD_WRITE,  0xBCAE, 0x0009} ,  	// LL_CDC_THR_ADJ_END_POS
{SENSOR_WORD_WRITE,  0xBCD8, 0x00C8} ,  	// LL_PCR_START_BM
{SENSOR_WORD_WRITE,  0xBCDA, 0x0A28} ,  	// LL_PCR_END_BM
{SENSOR_WORD_WRITE,  0x3380, 0x04CF} ,	//0x0504} ,  	// KERNEL_CONFIG
{SENSOR_BYTE_WRITE,  0xBC94, 0x12} ,  	// LL_GB_START_THRESHOLD_0
{SENSOR_BYTE_WRITE,  0xBC95, 0x0C} ,  	// LL_GB_START_THRESHOLD_1
{SENSOR_BYTE_WRITE,  0xBC9C, 0x37} ,  	// LL_GB_END_THRESHOLD_0
{SENSOR_BYTE_WRITE,  0xBC9D, 0x24} ,  	// LL_GB_END_THRESHOLD_1
{SENSOR_WORD_WRITE,  0x33B0, 0x2A16} ,  	// FFNR_ALPHA_BETA
{SENSOR_BYTE_WRITE,  0xBC8A, 0x00} ,  	// LL_START_FF_MIX_THRESH_Y
{SENSOR_BYTE_WRITE,  0xBC8B, 0x28} ,  	// LL_END_FF_MIX_THRESH_Y
{SENSOR_BYTE_WRITE,  0xBC8C, 0x00} ,  	// LL_START_FF_MIX_THRESH_YGAIN
{SENSOR_BYTE_WRITE,  0xBC8D, 0x01} ,  	// LL_END_FF_MIX_THRESH_YGAIN
{SENSOR_BYTE_WRITE,  0xBC8E, 0x1F} ,  	// LL_START_FF_MIX_THRESH_GAIN
{SENSOR_BYTE_WRITE,  0xBC8F, 0x00} ,  	// LL_END_FF_MIX_THRESH_GAIN
{SENSOR_BYTE_WRITE,  0xBCC0, 0x20} ,  	// LL_SFFB_RAMP_START
{SENSOR_BYTE_WRITE,  0xBCC1, 0x03} ,  	// LL_SFFB_RAMP_STOP
{SENSOR_BYTE_WRITE,  0xBCC2, 0x1E} ,  	// LL_SFFB_SLOPE_START
{SENSOR_BYTE_WRITE,  0xBCC3, 0x0F} ,  	// LL_SFFB_SLOPE_STOP
{SENSOR_BYTE_WRITE,  0xBCC4, 0x0A} ,  	// LL_SFFB_THSTART
{SENSOR_BYTE_WRITE,  0xBCC5, 0xAF} ,  	// LL_SFFB_THSTOP
{SENSOR_WORD_WRITE,  0xBCBA, 0x0009} ,  	// LL_SFFB_CONFIG
// FTB setup
//;REG= 0xBC14, 0xFFFE} ,  	// LL_GAMMA_FADE_TO_BLACK_START_POS
//;REG= 0xBC16, 0xFFFF} ,  	// LL_GAMMA_FADE_TO_BLACK_END_POS
//
{SENSOR_BYTE_WRITE,  0xBC6A, 0x04} ,  	// LL_START_APERTURE_INTEGER_GAIN
{SENSOR_BYTE_WRITE,  0xBC6B, 0x00} ,  	// LL_END_APERTURE_INTEGER_GAIN
{SENSOR_BYTE_WRITE,  0xBC6C, 0x00} ,  	// LL_START_APERTURE_EXP_GAIN
{SENSOR_BYTE_WRITE,  0xBC6D, 0x00} ,  	// LL_END_APERTURE_EXP_GAIN
{SENSOR_BYTE_WRITE,  0xBCE2, 0x0A} ,  	// LL_START_POS_KNEE
{SENSOR_BYTE_WRITE,  0xBCE3, 0x30} ,  	// LL_END_POS_KNEE
{SENSOR_BYTE_WRITE,  0xBCE4, 0x0A} ,  	// LL_START_NEG_KNEE
{SENSOR_BYTE_WRITE,  0xBCE5, 0x30} ,  	// LL_END_NEG_KNEE
{SENSOR_WORD_WRITE,  0x33BA, 0x001F} ,  	// APEDGE_CONTROL
{SENSOR_WORD_WRITE,  0x33BE, 0x0000} ,  	// UA_KNEE_L
{SENSOR_WORD_WRITE,  0x33C2, 0x4300} ,  	// UA_WEIGHTS
{SENSOR_BYTE_WRITE,  0xBC62, 0x0E} ,  	// LL_START_APERTURE_KPGAIN
{SENSOR_BYTE_WRITE,  0xBC63, 0x1C} ,  	// LL_END_APERTURE_KPGAIN
{SENSOR_BYTE_WRITE,  0xBC64, 0x0E} ,  	// LL_START_APERTURE_KNGAIN
{SENSOR_BYTE_WRITE,  0xBC65, 0x1C} ,  	// LL_END_APERTURE_KNGAIN
{SENSOR_WORD_WRITE,  0xA81C, 0x0040} ,  	// AE_TRACK_MIN_AGAIN
// -- Rev1, 02232011, Alias
// modified for low light SNR test
{SENSOR_WORD_WRITE,  0xA820, 0x0200} ,	//0x01FC} ,  	// AE_TRACK_MAX_AGAIN
{SENSOR_WORD_WRITE,  0xA822, 0x0080} ,  	// AE_TRACK_MIN_DGAIN
// -- Rev1, 02232011, Alias
// modified for low light SNR test
{SENSOR_WORD_WRITE,  0xA824, 0x0100} ,	//0x00A0} ,  	// AE_TRACK_MAX_DGAIN
{SENSOR_WORD_WRITE,  0xA81A, 0x0DB8} ,  	// AE_TRACK_MAX_INT_TIME_ROWS
// -- Rev1, 02232011, Alias
// change LL_saturation to reach 120% of saturation
{SENSOR_BYTE_WRITE,  0xBC56, 0x80} ,	//0x6A} ,  	// LL_START_CCM_SATURATION} ,	// 144
{SENSOR_BYTE_WRITE,  0xBC57, 0x55} ,  	// LL_END_CCM_SATURATION} ,	// 85
{SENSOR_BYTE_WRITE,  0xBCDE, 0x03} ,  	// LL_START_SYS_THRESHOLD
{SENSOR_BYTE_WRITE,  0xBCDF, 0x50} ,  	// LL_STOP_SYS_THRESHOLD
{SENSOR_BYTE_WRITE,  0xBCE0, 0x08} ,  	// LL_START_SYS_GAIN
{SENSOR_BYTE_WRITE,  0xBCE1, 0x03} ,  	// LL_STOP_SYS_GAIN
{SENSOR_WORD_WRITE,  0xBCD0, 0x000A} ,  	// LL_SFFB_SOBEL_FLAT_START
{SENSOR_WORD_WRITE,  0xBCD2, 0x00CC} ,  	// LL_SFFB_SOBEL_FLAT_STOP
{SENSOR_WORD_WRITE,  0xBCD4, 0x001E} ,  	// LL_SFFB_SOBEL_SHARP_START
{SENSOR_WORD_WRITE,  0xBCD6, 0x00FF} ,  	// LL_SFFB_SOBEL_SHARP_STOP
{SENSOR_BYTE_WRITE,  0xBCC6, 0x00} ,  	// LL_SFFB_SHARPENING_START
{SENSOR_BYTE_WRITE,  0xBCC7, 0x00} ,  	// LL_SFFB_SHARPENING_STOP
{SENSOR_BYTE_WRITE,  0xBCC8, 0x2F} ,  	// LL_SFFB_FLATNESS_START
{SENSOR_BYTE_WRITE,  0xBCC9, 0x40} ,  	// LL_SFFB_FLATNESS_STOP
{SENSOR_BYTE_WRITE,  0xBCCA, 0x04} ,  	// LL_SFFB_TRANSITION_START
{SENSOR_BYTE_WRITE,  0xBCCB, 0x00} ,  	// LL_SFFB_TRANSITION_STOP
{SENSOR_BYTE_WRITE,  0xBCE6, 0x03} ,  	// LL_SFFB_ZERO_ENABLE
{SENSOR_BYTE_WRITE,  0xC8ED, 0x03} ,  	// CAM_TX_ENABLE_MODE
{SENSOR_WORD_WRITE,  0x098E, 0x3C02} ,  	// LOGICAL_ADDRESS_ACCESS
{SENSOR_WORD_WRITE,  0xBC02, 0x017E} ,  	// LL_ALGO



//;[gamma- neutral]
{SENSOR_BYTE_WRITE,  0xBC2B, 0x00} ,  	// LL_GAMMA_NEUTRAL_CURVE_0
{SENSOR_BYTE_WRITE,  0xBC2C, 0x06} ,  	// LL_GAMMA_NEUTRAL_CURVE_1
{SENSOR_BYTE_WRITE,  0xBC2D, 0x14} ,  	// LL_GAMMA_NEUTRAL_CURVE_2
{SENSOR_BYTE_WRITE,  0xBC2E, 0x31} ,  	// LL_GAMMA_NEUTRAL_CURVE_3
{SENSOR_BYTE_WRITE,  0xBC2F, 0x53} ,  	// LL_GAMMA_NEUTRAL_CURVE_4
{SENSOR_BYTE_WRITE,  0xBC30, 0x6E} ,  	// LL_GAMMA_NEUTRAL_CURVE_5
{SENSOR_BYTE_WRITE,  0xBC31, 0x84} ,  	// LL_GAMMA_NEUTRAL_CURVE_6
{SENSOR_BYTE_WRITE,  0xBC32, 0x98} ,  	// LL_GAMMA_NEUTRAL_CURVE_7
{SENSOR_BYTE_WRITE,  0xBC33, 0xA7} ,  	// LL_GAMMA_NEUTRAL_CURVE_8
{SENSOR_BYTE_WRITE,  0xBC34, 0xB5} ,  	// LL_GAMMA_NEUTRAL_CURVE_9
{SENSOR_BYTE_WRITE,  0xBC35, 0xC1} ,  	// LL_GAMMA_NEUTRAL_CURVE_10
{SENSOR_BYTE_WRITE,  0xBC36, 0xCB} ,  	// LL_GAMMA_NEUTRAL_CURVE_11
{SENSOR_BYTE_WRITE,  0xBC37, 0xD5} ,  	// LL_GAMMA_NEUTRAL_CURVE_12
{SENSOR_BYTE_WRITE,  0xBC38, 0xDD} ,  	// LL_GAMMA_NEUTRAL_CURVE_13
{SENSOR_BYTE_WRITE,  0xBC39, 0xE5} ,  	// LL_GAMMA_NEUTRAL_CURVE_14
{SENSOR_BYTE_WRITE,  0xBC3A, 0xEC} ,  	// LL_GAMMA_NEUTRAL_CURVE_15
{SENSOR_BYTE_WRITE,  0xBC3B, 0xF3} ,  	// LL_GAMMA_NEUTRAL_CURVE_16
{SENSOR_BYTE_WRITE,  0xBC3C, 0xF9} ,  	// LL_GAMMA_NEUTRAL_CURVE_17
{SENSOR_BYTE_WRITE,  0xBC3D, 0xFF} ,  	// LL_GAMMA_NEUTRAL_CURVE_18
{SENSOR_BYTE_WRITE,  0xBC51, 0x04} ,  	// LL_GAMMA_CURVE_SELECTOR


//;**********************************************************************************************************
//; [Section8]	} ,	// Ports, & special features
//;**********************************************************************************************************

//  Sepia effect
{SENSOR_WORD_WRITE,  0x098E, 0x1000 } ,
{SENSOR_BYTE_WRITE,  0xDC3A, 0x23} ,  	// SYS_SEPIA_CR
{SENSOR_BYTE_WRITE,  0xDC3B, 0xB2} ,  	// SYS_SEPIA_CB

//;**********************************************************************************************************
//; [End of Initial]	} ,	// Run MCU
//;**********************************************************************************************************

//;[MIPI enable]
{SENSOR_WORD_WRITE,  0x301A, 0x107C} ,  	// RESET_REGISTER
{SENSOR_WORD_WRITE,  0x3400, 0x7A26} ,  	// MIPI_CONTROL
{SENSOR_WORD_WRITE,  0x3400, 0x7A26} ,  	// MIPI_CONTROL
{SENSOR_WORD_WRITE,  0x001A, 0x0018} ,  	// RESET_AND_MISC_CONTROL
{SENSOR_WORD_WRITE,  0x001A, 0x001C} ,  	// RESET_AND_MISC_CONTROL
{SENSOR_WORD_WRITE,  0x3CA0, 0x0001} ,  	// TXSS_PARAMETERS
{SENSOR_WORD_WRITE,  0xC8D4, 0x0000} ,  	// CAM_OUTPUT_1_MIPICHANNEL
{SENSOR_WORD_WRITE,  0x3CA2, 0x0087} ,  	// TXC_PARAMETERS
{SENSOR_WORD_WRITE,  0x3402, 0x0011} ,  	// MIPI_STATUS
{SENSOR_WORD_WRITE,  0x3400, 0x7A24} ,  	// MIPI_CONTROL
{SENSOR_WORD_WRITE,  0xD822, 0x4710} ,  	// JPEG_JPSS_CTRL_VAR

// following 2 lines of setting are only used by DevWare and no need to port.
//SERIAL_{0xCA, 0x00, 0x8001, 8:16   // FPGA disabled
//SERIAL_{0xCA, 0x00, 0x0006, 8:16   // FPGA into MIPI single lane mode
//

{SENSOR_WORD_WRITE,  0x0018, 0x2008} ,  	// STANDBY_CONTROL_AND_STATUS, Run MCU
{SENSOR_WAIT_MS,0,150}, //DELAY= 150

// for DevWare use only
//State= Detect Master Clock, 1	} ,	// Detect system clock


//; [8.1 AF - Initilize Internal VCM]
{SENSOR_WORD_WRITE,  0x098E, 0x1000} ,  	// LOGICAL_ADD
{SENSOR_BYTE_WRITE,  0xC400, 0x88} ,  	// AFM_ALGO
{SENSOR_BYTE_WRITE,  0x8419, 0x05} ,  	// SEQ_STATE_CFG_1_AF
// AF_MODE, set to skip 1 frame
{SENSOR_WORD_WRITE,  0xB002, 0x0002} ,	// AF_MODE

// --Rev1, 02232011, Alias (Modify AF step settings)
{SENSOR_WORD_WRITE,  0xC40C, 0x00FF} ,	// afm_pos_max
{SENSOR_BYTE_WRITE,  0xB012, 0x08} ,	// AF_FS_NUM_STEPS
{SENSOR_BYTE_WRITE,  0xB018, 30 } ,	//32} ,  	// AF_FS_POS_0
{SENSOR_BYTE_WRITE,  0xB019, 54 } ,	//40} ,  	// AF_FS_POS_1
{SENSOR_BYTE_WRITE,  0xB01A, 72 } ,	//48} ,  	// AF_FS_POS_2
{SENSOR_BYTE_WRITE,  0xB01B, 86 } ,	//56} ,  	// AF_FS_POS_3
{SENSOR_BYTE_WRITE,  0xB01C, 98 } ,	//66} ,  	// AF_FS_POS_4
{SENSOR_BYTE_WRITE,  0xB01D, 110} ,	//82} ,  	// AF_FS_POS_5
{SENSOR_BYTE_WRITE,  0xB01E, 120} ,	//104} ,	// AF_FS_POS_6
{SENSOR_BYTE_WRITE,  0xB01F, 128} ,	//128} ,	// AF_FS_POS_7
{SENSOR_BYTE_WRITE,  0x8404, 0x05} ,  	// SEQ_CMD
{SENSOR_WAIT_MS,0, 100},
{SENSOR_WORD_WRITE,  0x0620, 0x8000} ,  	// VCM_CONTROL
{SEQUENCE_END, 0x0000},
};



// ---- end of initialization ---- //

//-

static struct sensor_reg_ex mode_2592x1944_rev1[] =
{
	{SENSOR_WORD_WRITE,0x098e,0x843c},
//  {SENSOR_BYTE_WRITE,0x843C,0x05}, 	// JPEG_JPSS_CTRL_VAR
  {SENSOR_BYTE_WRITE,0x843C,0xFF}, 	// JPEG_JPSS_CTRL_VAR
	{SENSOR_BYTE_WRITE,0x8404,0x02},
{SEQUENCE_END, 0x0000}
};

static struct sensor_reg_ex mode_1280x960_rev1_restart[] =
{
	{SENSOR_WORD_WRITE,0x098e,0x843c},
  {SENSOR_BYTE_WRITE,0x843C,0xFF}, 	// JPEG_JPSS_CTRL_VAR
	{SENSOR_BYTE_WRITE,0x8404,0x01},
{SEQUENCE_END, 0x0000}
};


static struct sensor_reg_ex ColorEffect_None[] = {
{SENSOR_WORD_WRITE,0x098E, 0x1000} ,  // LOGICAL_ADDRESS_ACCESS [SYS_SELECT_FX]
{SENSOR_BYTE_WRITE,0xDC38, 0x00} , // SYS_SELECT_FX
// Mode refresh
{SENSOR_BYTE_WRITE,0x8404, 0x06} ,	// SEQ_CMD
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex ColorEffect_Mono[] = {
{SENSOR_WORD_WRITE,0x098E, 0x1000} ,  // LOGICAL_ADDRESS_ACCESS [SYS_SELECT_FX]
{SENSOR_BYTE_WRITE,0xDC38, 0x01} , // SYS_SELECT_FX
// Mode refresh
{SENSOR_BYTE_WRITE,0x8404, 0x06} ,	// SEQ_CMD
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex ColorEffect_Sepia[] = {
{SENSOR_WORD_WRITE,0x098E, 0x1000} ,  // LOGICAL_ADDRESS_ACCESS [SYS_SELECT_FX]
{SENSOR_BYTE_WRITE,0xDC38, 0x02} , // SYS_SELECT_FX
// Mode refresh
{SENSOR_BYTE_WRITE,0x8404, 0x06} , // SEQ_CMD
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex ColorEffect_Negative[] = {
{SENSOR_WORD_WRITE,0x098E, 0x1000} ,  // LOGICAL_ADDRESS_ACCESS [SYS_SELECT_FX]
{SENSOR_BYTE_WRITE,0xDC38, 0x03} , // SYS_SELECT_FX
// Mode refresh
{SENSOR_BYTE_WRITE,0x8404, 0x06} ,	// SEQ_CMD
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex ColorEffect_Solarize[] = {
{SENSOR_WORD_WRITE,0x098E, 0x1000} ,  // LOGICAL_ADDRESS_ACCESS [SYS_SELECT_FX]
{SENSOR_BYTE_WRITE,0xDC38, 0x04} , // SYS_SELECT_FX
// Mode refresh
{SENSOR_BYTE_WRITE,0x8404, 0x06} ,	// SEQ_CMD
{SENSOR_TABLE_END, 0x0000}
};

//Sensor ISP Not Support this function
static struct sensor_reg_ex ColorEffect_Posterize[] = {
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex Whitebalance_Auto[] = {
{SENSOR_WORD_WRITE, 0x098E, 0x1000} ,	// LOGICAL_ADDRESS_ACCESS [LL_ALGO]
{SENSOR_BYTE_WRITE,0x8410, 0x02} , // SEQ_STATE_CFG_0_AWB
{SENSOR_BYTE_WRITE,0x8418, 0x02} , // SEQ_STATE_CFG_1_AWB
{SENSOR_BYTE_WRITE,0x8420, 0x02} , // SEQ_STATE_CFG_2_AWB
{SENSOR_BYTE_WRITE,0xAC44, 0x00} , // AWB_LEFT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0xAC45, 0x7F} , // AWB_RIGHT_CCM_POS_RANGE_LIMIT

{SENSOR_BYTE_WRITE,0xACB0, 0x31} , // AWB_RG_MIN
{SENSOR_BYTE_WRITE,0xACB1, 0x5F} , // AWB_RG_MAX
{SENSOR_BYTE_WRITE,0xACB4, 0x22} , // AWB_BG_MIN
{SENSOR_BYTE_WRITE,0xACB5, 0x5B} , // AWB_BG_MAX
//A_Light CCM & R/G B/g ratios
{SENSOR_WORD_WRITE, 0xAC46, 0x0235} , // AWB_LEFT_CCM_0
{SENSOR_WORD_WRITE, 0xAC48, 0xFE7C} , // AWB_LEFT_CCM_1
{SENSOR_WORD_WRITE, 0xAC4A, 0xFFEC} , // AWB_LEFT_CCM_2
{SENSOR_WORD_WRITE, 0xAC4C, 0xFFBB} , // AWB_LEFT_CCM_3
{SENSOR_WORD_WRITE, 0xAC4E, 0x0196} , // AWB_LEFT_CCM_4
{SENSOR_WORD_WRITE, 0xAC50, 0xFFB0} , // AWB_LEFT_CCM_5
{SENSOR_WORD_WRITE, 0xAC52, 0xFFEC} , // AWB_LEFT_CCM_6
{SENSOR_WORD_WRITE, 0xAC54, 0xFE92} , // AWB_LEFT_CCM_7
{SENSOR_WORD_WRITE, 0xAC56, 0x0282} , // AWB_LEFT_CCM_8
{SENSOR_WORD_WRITE, 0xAC58, 0x00C6} , // AWB_LEFT_CCM_R2BRATIO
//D65_Light CCM
{SENSOR_WORD_WRITE, 0xAC5C, 0x01F6} , // AWB_RIGHT_CCM_0
{SENSOR_WORD_WRITE, 0xAC5E, 0xFEBB} , // AWB_RIGHT_CCM_1
{SENSOR_WORD_WRITE, 0xAC60, 0x0014} , // AWB_RIGHT_CCM_2
{SENSOR_WORD_WRITE, 0xAC62, 0xFFA2} , // AWB_RIGHT_CCM_3
{SENSOR_WORD_WRITE, 0xAC64, 0x0191} , // AWB_RIGHT_CCM_4
{SENSOR_WORD_WRITE, 0xAC66, 0xFFCD} , // AWB_RIGHT_CCM_5
{SENSOR_WORD_WRITE, 0xAC68, 0x000D} , // AWB_RIGHT_CCM_6
{SENSOR_WORD_WRITE, 0xAC6A, 0xFF1E} , // AWB_RIGHT_CCM_7
{SENSOR_WORD_WRITE, 0xAC6C, 0x01FC} , // AWB_RIGHT_CCM_8
{SENSOR_WORD_WRITE, 0xAC6E, 0x0069} , // AWB_RIGHT_CCM_R2BRATIO
{SENSOR_BYTE_WRITE,0x8404, 0x06} ,	 // SEQ_CMD, Refresh Mode
// set APGA
{SENSOR_BYTE_WRITE,0xD005,	0x00}	 , // PGA_CURRENT_ZONE -- Specify PGA Zone to 0~2
{SENSOR_WORD_WRITE, 0xD002,	0x8007},	// PGA_ALGO
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex Whitebalance_Incandescent[] = {
//[b.5 MWB: AL]
// new MWB for AL
// -- Rev10, 12162010, Alias
{SENSOR_WORD_WRITE, 0x098E, 0x8410} , // LOGICAL_ADDRESS_ACCESS [SEQ_STATE_CFG_0_AWB]
{SENSOR_BYTE_WRITE,0x8410, 0x02} , // SEQ_STATE_CFG_0_AWB
{SENSOR_BYTE_WRITE,0x8418, 0x02} , // SEQ_STATE_CFG_1_AWB
{SENSOR_BYTE_WRITE,0x8420, 0x02} , // SEQ_STATE_CFG_2_AWB
{SENSOR_BYTE_WRITE,0xAC44, 0x7F} , // AWB_LEFT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0xAC45, 0x7F} , // AWB_RIGHT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0x8404, 0x06} , // SEQ_CMD
{SENSOR_BYTE_WRITE,0xAC08, 0x00} , // AWB_CUR_CCM_POS
//
{SENSOR_BYTE_WRITE,0xACB0, 0x59} , // AWB_RG_MIN
{SENSOR_BYTE_WRITE,0xACB1, 0x61} , // AWB_RG_MAX
{SENSOR_BYTE_WRITE,0xACB4, 0x23} , // AWB_BG_MIN
{SENSOR_BYTE_WRITE,0xACB5, 0x2C} , // AWB_BG_MAX

//Left CCM & R/G B/g ratios
{SENSOR_WORD_WRITE, 0xAC10, 0x0435} , // AWB_CCM_0
{SENSOR_WORD_WRITE, 0xAC12, 0xFCF6} , // AWB_CCM_1
{SENSOR_WORD_WRITE, 0xAC14, 0xFFD9} , // AWB_CCM_2
{SENSOR_WORD_WRITE, 0xAC16, 0xFFB3} , // AWB_CCM_3
{SENSOR_WORD_WRITE, 0xAC18, 0x01AB} , // AWB_CCM_4
{SENSOR_WORD_WRITE, 0xAC1A, 0xFFA6} , // AWB_CCM_5
{SENSOR_WORD_WRITE, 0xAC1C, 0xFFEA} , // AWB_CCM_6
{SENSOR_WORD_WRITE, 0xAC1E, 0xFE62} , // AWB_CCM_7
{SENSOR_WORD_WRITE, 0xAC20, 0x02B7} , // AWB_CCM_8
//Right CCM
{SENSOR_WORD_WRITE, 0xAC5C, 0x0435} , // AWB_RIGHT_CCM_0
{SENSOR_WORD_WRITE, 0xAC5E, 0xFCF6} , // AWB_RIGHT_CCM_1
{SENSOR_WORD_WRITE, 0xAC60, 0xFFD9} , // AWB_RIGHT_CCM_2
{SENSOR_WORD_WRITE, 0xAC62, 0xFFB3} , // AWB_RIGHT_CCM_3
{SENSOR_WORD_WRITE, 0xAC64, 0x01AB} , // AWB_RIGHT_CCM_4
{SENSOR_WORD_WRITE, 0xAC66, 0xFFA6} , // AWB_RIGHT_CCM_5
{SENSOR_WORD_WRITE, 0xAC68, 0xFFEA} , // AWB_RIGHT_CCM_6
{SENSOR_WORD_WRITE, 0xAC6A, 0xFE62} , // AWB_RIGHT_CCM_7
{SENSOR_WORD_WRITE, 0xAC6C, 0x02B7} , // AWB_RIGHT_CCM_8

{SENSOR_BYTE_WRITE,0xD005, 0x00} ,	// PGA_CURRENT_ZONE -- Specify PGA Zone to 0~2
{SENSOR_WORD_WRITE, 0xD002, 0x8003} ,	// PGA_ALGO

{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex Whitebalance_Daylight[] = {
//[b.2 MWB: D65]
{SENSOR_WORD_WRITE, 0x098E, 0x8410} , // LOGICAL_ADDRESS_ACCESS [SEQ_STATE_CFG_0_AWB]
{SENSOR_BYTE_WRITE,0x8410, 0x02} , //0x01} , // SEQ_STATE_CFG_0_AWB
{SENSOR_BYTE_WRITE,0x8418, 0x02} , //0x01} , // SEQ_STATE_CFG_1_AWB
{SENSOR_BYTE_WRITE,0x8420, 0x02} , //0x01} , // SEQ_STATE_CFG_2_AWB
{SENSOR_BYTE_WRITE,0xAC44, 0x7F} , // AWB_LEFT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0xAC45, 0x7F} , // AWB_RIGHT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0x8404, 0x06} , // SEQ_CMD
{SENSOR_BYTE_WRITE,0xAC08, 0x7F} , // AWB_CUR_CCM_POS
//
{SENSOR_BYTE_WRITE,0xACB0, 0x3B} , // AWB_RG_MIN
{SENSOR_BYTE_WRITE,0xACB1, 0x43} , // AWB_RG_MAX
{SENSOR_BYTE_WRITE,0xACB4, 0x42} , // AWB_BG_MIN
{SENSOR_BYTE_WRITE,0xACB5, 0x4E} , // AWB_BG_MAX
//Left CCM & R/G B/g ratios
{SENSOR_WORD_WRITE, 0xAC10, 0x02CD} , // AWB_CCM_0
{SENSOR_WORD_WRITE, 0xAC12, 0xFE18} , // AWB_CCM_1
{SENSOR_WORD_WRITE, 0xAC14, 0x0000} , // AWB_CCM_2
{SENSOR_WORD_WRITE, 0xAC16, 0xFF98} , // AWB_CCM_3
{SENSOR_WORD_WRITE, 0xAC18, 0x01A3} , // AWB_CCM_4
{SENSOR_WORD_WRITE, 0xAC1A, 0xFFB6} , // AWB_CCM_5
{SENSOR_WORD_WRITE, 0xAC1C, 0x000C} , // AWB_CCM_6
{SENSOR_WORD_WRITE, 0xAC1E, 0xFF2A} , // AWB_CCM_7
{SENSOR_WORD_WRITE, 0xAC20, 0x01CD} , // AWB_CCM_8
//Right CCM
{SENSOR_WORD_WRITE, 0xAC5C, 0x02CD} , // AWB_RIGHT_CCM_0
{SENSOR_WORD_WRITE, 0xAC5E, 0xFE18} , // AWB_RIGHT_CCM_1
{SENSOR_WORD_WRITE, 0xAC60, 0x0000} , // AWB_RIGHT_CCM_2
{SENSOR_WORD_WRITE, 0xAC62, 0xFF98} , // AWB_RIGHT_CCM_3
{SENSOR_WORD_WRITE, 0xAC64, 0x01A3} , // AWB_RIGHT_CCM_4
{SENSOR_WORD_WRITE, 0xAC66, 0xFFB6} , // AWB_RIGHT_CCM_5
{SENSOR_WORD_WRITE, 0xAC68, 0x000C} , // AWB_RIGHT_CCM_6
{SENSOR_WORD_WRITE, 0xAC6A, 0xFF2A} , // AWB_RIGHT_CCM_7
{SENSOR_WORD_WRITE, 0xAC6C, 0x01CD} , // AWB_RIGHT_CCM_8

{SENSOR_BYTE_WRITE,0xD005, 0x02} , 	// PGA_CURRENT_ZONE -- Specify PGA Zone to 0~2
{SENSOR_WORD_WRITE, 0xD002, 0x8003} , 	// PGA_ALGO

{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex Whitebalance_Fluorescent[] = {
{SENSOR_WORD_WRITE, 0x098E, 0x8410} , // LOGICAL_ADDRESS_ACCESS [SEQ_STATE_CFG_0_AWB]
{SENSOR_BYTE_WRITE,0x8410, 0x02} , // SEQ_STATE_CFG_0_AWB
{SENSOR_BYTE_WRITE,0x8418, 0x02} , // SEQ_STATE_CFG_1_AWB
{SENSOR_BYTE_WRITE,0x8420, 0x02} , // SEQ_STATE_CFG_2_AWB
{SENSOR_BYTE_WRITE,0xAC44, 0x7F} , // AWB_LEFT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0xAC45, 0x7F} , // AWB_RIGHT_CCM_POS_RANGE_LIMIT
{SENSOR_BYTE_WRITE,0x8404, 0x06} , // SEQ_CMD
{SENSOR_BYTE_WRITE,0xAC08, 0x32} , // AWB_CUR_CCM_POS
//
{SENSOR_BYTE_WRITE,0xACB0, 0x48} , // AWB_RG_MIN
{SENSOR_BYTE_WRITE,0xACB1, 0x51} , // AWB_RG_MAX
{SENSOR_BYTE_WRITE,0xACB4, 0x2A} , // AWB_BG_MIN
{SENSOR_BYTE_WRITE,0xACB5, 0x36} , // AWB_BG_MAX
//Left CCM
{SENSOR_WORD_WRITE, 0xAC10, 0x03A1} , // AWB_CCM_0
{SENSOR_WORD_WRITE, 0xAC12, 0xFD6B} , // AWB_CCM_1
{SENSOR_WORD_WRITE, 0xAC14, 0xFFF7} , // AWB_CCM_2
{SENSOR_WORD_WRITE, 0xAC16, 0xFFAA} , // AWB_CCM_3
{SENSOR_WORD_WRITE, 0xAC18, 0x01A7} , // AWB_CCM_4
{SENSOR_WORD_WRITE, 0xAC1A, 0xFFB2} , // AWB_CCM_5
{SENSOR_WORD_WRITE, 0xAC1C, 0xFFF7} , // AWB_CCM_6
{SENSOR_WORD_WRITE, 0xAC1E, 0xFEAC} , // AWB_CCM_7
{SENSOR_WORD_WRITE, 0xAC20, 0x0260} , // AWB_CCM_8
//Right CCM
{SENSOR_WORD_WRITE, 0xAC5C, 0x03A1} , // AWB_RIGHT_CCM_0
{SENSOR_WORD_WRITE, 0xAC5E, 0xFD6B} , // AWB_RIGHT_CCM_1
{SENSOR_WORD_WRITE, 0xAC60, 0xFFF7} , // AWB_RIGHT_CCM_2
{SENSOR_WORD_WRITE, 0xAC62, 0xFFAA} , // AWB_RIGHT_CCM_3
{SENSOR_WORD_WRITE, 0xAC64, 0x01A7} , // AWB_RIGHT_CCM_4
{SENSOR_WORD_WRITE, 0xAC66, 0xFFB2} , // AWB_RIGHT_CCM_5
{SENSOR_WORD_WRITE, 0xAC68, 0xFFF7} , // AWB_RIGHT_CCM_6
{SENSOR_WORD_WRITE, 0xAC6A, 0xFEAC} , // AWB_RIGHT_CCM_7
{SENSOR_WORD_WRITE, 0xAC6C, 0x0260} , // AWB_RIGHT_CCM_8

{SENSOR_BYTE_WRITE,0xD005, 0x01} ,	// PGA_CURRENT_ZONE -- Specify PGA Zone to 0~2
{SENSOR_WORD_WRITE, 0xD002, 0x8003} ,	// PGA_ALGO

{SENSOR_TABLE_END, 0x0000}
};

//+ EV

static struct sensor_reg_ex EV_zero[] = {
//[5.3 0EV -- mean=140]	//
{SENSOR_WORD_WRITE, 0x098E, 0x1000} , 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
{SENSOR_BYTE_WRITE,0xA409, 0x46} , 	// AE_RULE_BASE_TARGET
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex EV_plus_1[] = {
//[5.4 +1EV -- mean=160]	//
{SENSOR_WORD_WRITE, 0x098E, 0x1000} , 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
{SENSOR_BYTE_WRITE,0xA409, 0x53} , 	// AE_RULE_BASE_TARGET
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex EV_plus_2[] = {
//[5.5 +2EV -- mean=180]	//
{SENSOR_WORD_WRITE, 0x098E, 0x1000} , 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
{SENSOR_BYTE_WRITE,0xA409, 0x66} , 	// AE_RULE_BASE_TARGET
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex EV_minus_1[] = {
//[5.2 -1EV -- mean=120]	//
{SENSOR_WORD_WRITE, 0x098E, 0x1000} , 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
{SENSOR_BYTE_WRITE,0xA409, 0x37} , 	// AE_RULE_BASE_TARGET
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg_ex EV_minus_2[] = {
//[5.1 -2EV -- mean=100]	//
{SENSOR_WORD_WRITE, 0x098E, 0x1000} , 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
{SENSOR_BYTE_WRITE,0xA409, 0x2E} , 	// AE_RULE_BASE_TARGET
{SENSOR_TABLE_END, 0x0000}
};

//-


static struct sensor_reg_ex Autofocus_Trigger[] = {
//[8.2 AF - Full Scan ON]
//{0x098E, 0x10},
//{0x098F, 0x00}, 	// LOGICAL_ADDRESS_ACCESS [SEQ_STATE_CFG_1_AF]
//{0x8419, 0x05}, 	// SEQ_STATE_CFG_1_AF
//{0x8404, 0x06}, 	// SEQ_CMD
{SENSOR_WORD_WRITE, 0x098E, 0x1000} , 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
{SENSOR_BYTE_WRITE,0xB006, 0x01}, 	// AF_PROGRESS{SENSOR_TABLE_END, 0x0000}
{SENSOR_TABLE_END, 0x0000}
};

enum {
	SENSOR_MODE_2592x1944,
	SENSOR_MODE_1280x960,
};

static struct sensor_reg_ex *mode_table_rev1[] = {
	[SENSOR_MODE_2592x1944]  = mode_2592x1944_rev1,
	[SENSOR_MODE_1280x960]   = mode_1280x960_rev1,
};


static int sensor_read_reg(struct i2c_client *client, u16 addr, u16 *val)
{
	int err;
	struct i2c_msg msg[2];
	unsigned char data[4];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;

	msg[1].len = 1;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)
		return -EINVAL;

	memcpy(val, data+2, 1);
	*val=*val&0xff;

	return 0;
}

static int sensor_read_reg_word(struct i2c_client *client, u16 addr, u16 *val)
{
	int err;
	struct i2c_msg msg[2];
	unsigned char data[4];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len = 2;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)
		return -EINVAL;

  swap(*(data+2),*(data+3)); //swap high and low byte to match table format
	memcpy(val, data+2, 2);

	return 0;
}

static int sensor_write_reg(struct i2c_client *client, u16 addr, u16 val)
{
	int err;
	struct i2c_msg msg;
	unsigned char data[4];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);
	data[2] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 3;
	msg.buf = data;
	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("yuv_sensor : i2c transfer failed, retrying %x %x\n",
		       addr, val);
		pr_err("yuv_sensor : i2c transfer failed, count %x \n",
		       msg.addr);
//		msleep(3);
	} while (retry <= SENSOR_MAX_RETRIES);

	return err;
}

static int sensor_write_table(struct i2c_client *client,
			      const struct sensor_reg table[])
{
	int err;
	const struct sensor_reg *next;
	u16 val;

	pr_info("yuv %s\n",__func__);
	for (next = table; next->addr != SENSOR_TABLE_END; next++) {
		if (next->addr == SENSOR_WAIT_MS) {
			msleep(next->val);
			continue;
		}

		val = next->val;

		err = sensor_write_reg(client, next->addr, val);
		if (err)
			return err;
	}
	return 0;
}

static int sensor_write_reg_word(struct i2c_client *client, u16 addr, u16 val)
{
	int err;
	struct i2c_msg msg;
	unsigned char data[4];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);
  data[2] = (u8) (val >> 8);
	data[3] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 4;
	msg.buf = data;

	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("yuv_sensor : i2c transfer failed, retrying %x %x\n",
		       addr, val);
		pr_err("yuv_sensor : i2c transfer failed, count %x \n",
		       msg.addr);
	} while (retry <= SENSOR_MAX_RETRIES);

	return err;
}
static int sensor_write_table_ex(struct i2c_client *client,
			      const struct sensor_reg_ex table[])
{
	int err;
	const struct sensor_reg_ex *next;
	u16 val;

	pr_info("yuv %s\n",__func__);
	for (next = table; next->cmd != SENSOR_TABLE_END; next++) {
		if (next->cmd == SENSOR_WAIT_MS) {
			msleep(next->val);
			continue;
		}

		val = next->val;

    if (next->cmd == SENSOR_BYTE_WRITE)
		  err = sensor_write_reg(client, next->addr, val);
    else if (next->cmd == SENSOR_WORD_WRITE)
		  err = sensor_write_reg_word(client, next->addr, val);
		if (err)
			return err;
	}
	return 0;
}
static int get_sensor_current_width(struct i2c_client *client, u16 *val)
{
        int err;
        err = sensor_read_reg_word(client, 0xC86C, val);

        if (err)
          return err;

        return 0;
}

static int sensor_set_mode(struct sensor_info *info, struct sensor_mode *mode)
{
	int sensor_table;
	int err;
        u16 val;

	pr_info("%s: xres %u yres %u\n",__func__, mode->xres, mode->yres);

	if (mode->xres == 2592 && mode->yres == 1944)
		sensor_table = SENSOR_MODE_2592x1944;
	else if (mode->xres == 1280 && mode->yres == 960)
		sensor_table = SENSOR_MODE_1280x960;
	else {
		pr_err("%s: invalid resolution supplied to set mode %d %d\n",
		       __func__, mode->xres, mode->yres);
		return -EINVAL;
	}

//  get_sensor_current_width(info->i2c_client, &val);
  pr_info("val=%d",val);

  //check already program the sensor mode, Aptina support Context B fast switching capture mode back to preview mode
  //we don't need to re-program the sensor mode for 1280x960 table
//  if(!(val == SENSOR_1280_WIDTH_VAL && sensor_table == SENSOR_MODE_1280x960))
  {
//    err = sensor_write_table(info->i2c_client, mode_table[sensor_table]);
    if (sensor_table == SENSOR_MODE_1280x960)
    {
      if (g_initialized == 0)
      {
        err = sensor_write_table_ex(info->i2c_client, mode_table_rev1[sensor_table]);
        g_initialized = 1;
      }
      else
        err = sensor_write_table_ex(info->i2c_client, mode_1280x960_rev1_restart);
    }
    else
        err = sensor_write_table_ex(info->i2c_client, mode_table_rev1[sensor_table]);
//+ Some polling to make sure sensor is switch to 5MP/1.2MP mode...
    if (sensor_table == SENSOR_MODE_2592x1944)
    {
      int i=50;
      u16 testval=0xA0A0;

      for (i=0;i<50;i++)
      {
        sensor_read_reg(info->i2c_client, 0x8405, &testval);
        if (testval ==0x07)
           break;
        printk("testval=0x%X, i=%d",testval,i);
        msleep(10);
      }
    }
    else if (sensor_table == SENSOR_MODE_1280x960)
    {
      int i=50;
      u16 testval=0xA0A0;

      for (i=0;i<50;i++)
      {
        sensor_read_reg(info->i2c_client, 0x8405, &testval);
        if (testval ==0x03)
           break;
        printk("testval=0x%X, i=%d",testval,i);
        msleep(10);
      }
    }
//-
    if (err)
      return err;
  }

	info->mode = sensor_table;
	return 0;
}

static long sensor_ioctl(struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	struct sensor_info *info = file->private_data;
        int err=0;

	pr_info("yuv %s, cmd=0x%X\n",__func__,cmd);
	switch (cmd)
  {
  	case SENSOR_IOCTL_SET_MODE:
  	{
  		struct sensor_mode mode;
  		if (copy_from_user(&mode,
  				   (const void __user *)arg,
  				   sizeof(struct sensor_mode))) {
  			return -EFAULT;
  		}

  		return sensor_set_mode(info, &mode);
  	}
  	case SENSOR_IOCTL_GET_STATUS:
  	{

  		return 0;
  	}
    case SENSOR_IOCTL_SET_COLOR_EFFECT:
    {
      u8 coloreffect;
      if (copy_from_user(&coloreffect,(const void __user *)arg,
        sizeof(coloreffect))) {
        return -EFAULT;
      }

      switch(coloreffect)
      {
        case YUV_ColorEffect_None:
          err = sensor_write_table_ex(info->i2c_client, ColorEffect_None);
          break;
        case YUV_ColorEffect_Mono:
          err = sensor_write_table_ex(info->i2c_client, ColorEffect_Mono);
          break;
        case YUV_ColorEffect_Sepia:
          err = sensor_write_table_ex(info->i2c_client, ColorEffect_Sepia);
          break;
        case YUV_ColorEffect_Negative:
          err = sensor_write_table_ex(info->i2c_client, ColorEffect_Negative);
          break;
        case YUV_ColorEffect_Solarize:
          err = sensor_write_table_ex(info->i2c_client, ColorEffect_Solarize);
          break;
        case YUV_ColorEffect_Posterize:
          err = sensor_write_table_ex(info->i2c_client, ColorEffect_Posterize);
          break;
        default:
          break;
      }

      if (err)
      return err;

      return 0;
    }
    case SENSOR_IOCTL_SET_WHITE_BALANCE:
    {
      u8 whitebalance;

      if (copy_from_user(&whitebalance,(const void __user *)arg,
        sizeof(whitebalance))) {
        return -EFAULT;
      }
      printk("0x%X,0x%X\n",SENSOR_CUSTOM_IOCTL_GET_EV,SENSOR_CUSTOM_IOCTL_SET_EV);
      switch(whitebalance)
      {
        case YUV_Whitebalance_Auto:
          printk("=================WB: Auto\n");
          err = sensor_write_table_ex(info->i2c_client, Whitebalance_Auto);
          break;
        case YUV_Whitebalance_Incandescent:
          printk("=================WB: Incandescent\n");
          err = sensor_write_table_ex(info->i2c_client, Whitebalance_Incandescent);
          break;
        case YUV_Whitebalance_Daylight:
          err = sensor_write_table_ex(info->i2c_client, Whitebalance_Daylight);
          printk("=================WB: Daylight\n");
          break;
        case YUV_Whitebalance_Fluorescent:
          printk("=================WB: Fluorescent\n");
          err = sensor_write_table_ex(info->i2c_client, Whitebalance_Fluorescent);
          break;
        default:
          break;
      }

      if (err)
        return err;

      return 0;
    }
    case SENSOR_IOCTL_SET_SCENE_MODE:
    {
      return 0;
    }

    case SENSOR_CUSTOM_IOCTL_SET_AF_MODE:
    {
      custom_af_cmd_package AF_cmd;

      if (copy_from_user(&AF_cmd,(const void __user *)arg,
        sizeof(AF_cmd)))
      {
        return -EFAULT;
      }
      switch(AF_cmd.cmd)
      {
        case AF_CMD_START:
          pr_info("AF cmd start!\n");
          err = sensor_write_table_ex(info->i2c_client, Autofocus_Trigger);
          if (err)
             return err;
          break;
	 case AF_CMD_ABORT:
        {
               break;
        }
        case AF_CMD_SET_POSITION:
        case AF_CMD_SET_WINDOW_POSITION:
        case AF_CMD_SET_WINDOW_SIZE:
        case AF_CMD_SET_AFMODE:
        case AF_CMD_SET_CAF:
        default:
          pr_info("AF cmd %d not implemented yet\n",AF_cmd.cmd);
          return -1;
      }
      return 0;
    }
    case SENSOR_CUSTOM_IOCTL_GET_AF_MODE:
    {
	custom_af_cmd_package AF_cmd;
	if (copy_from_user(&AF_cmd,(const void __user *)arg,
        sizeof(AF_cmd)))
       {
        return -EFAULT;
       }
	switch(AF_cmd.cmd)
	{
	  case AF_CMD_GET_AF_STATUS:
	  {
            u16 val=0xa5a5;
            sensor_write_reg_word(info->i2c_client, 0x098e,0x1000);
            sensor_read_reg_word(info->i2c_client, 0xb000,&val);
            printk("AF_Status: [0xb000]=0x%X\n",val);
	     if (val & 0x10)
		 AF_cmd.data = 1; //locked
	     else
		 AF_cmd.data = 0; //busy
            copy_to_user((const void __user *)arg, &AF_cmd, sizeof(AF_cmd));
            break;
	   }
	   default:
	   	pr_info("AF cmd %d not implemented yet\n",AF_cmd.cmd);
		return -1;
	}
	return 0;
    }
    case SENSOR_CUSTOM_IOCTL_SET_EV:
    {
      short ev;

      if (copy_from_user(&ev,(const void __user *)arg, sizeof(short)))
      {
        return -EFAULT;
      }

      printk("SET_EV as %d\n",ev);

      if (ev == -2)
        err = sensor_write_table_ex(info->i2c_client, EV_minus_2);
      else if (ev == -1)
        err = sensor_write_table_ex(info->i2c_client, EV_minus_1);
      else if (ev == 0)
        err = sensor_write_table_ex(info->i2c_client, EV_zero);
      else if (ev == 1)
        err = sensor_write_table_ex(info->i2c_client, EV_plus_1);
      else if (ev == 2)
        err = sensor_write_table_ex(info->i2c_client, EV_plus_2);
      else
        err = -1;

      if (err)
        return err;
      return 0;
    }

    case SENSOR_CUSTOM_IOCTL_GET_EV:
    {
      short ev;
      u16 val;
      sensor_write_reg_word(info->i2c_client, 0x098E, 0x1000);
      err = sensor_read_reg(info->i2c_client, 0xA409, &val);

      printk("GET_EV: val=0x%X\n",val);

      if (err)
        return err;

      printk("GET_EV: val=0x%X\n",val);

      if (val <= 0x2E)
        ev=-2;
      else if (val <= 0x37)
        ev=-1;
      else if (val <= 0x46)
        ev=0;
      else if (val <= 0x53)
        ev=1;
      else if (val > 0x53)
        ev=2;
      if (copy_to_user((const void __user *)arg, &ev, sizeof(short)))
      {
        return -EFAULT;
      }
      if (err)
        return err;

      return 0;
    }

  	default:
  		return -EINVAL;
	}
	return 0;
}

static int sensor_open(struct inode *inode, struct file *file)
{
	pr_info("yuv %s\n",__func__);
	file->private_data = info;
	if (info->pdata && info->pdata->power_on)
		info->pdata->power_on();
	return 0;
}



int mi5140_sensor_release(struct inode *inode, struct file *file)
{
  if (info->pdata && info->pdata->power_off)
  {
    msleep(500);
    info->pdata->power_off();
  }
  file->private_data = NULL;
  g_initialized=0;
  return 0;
}


static const struct file_operations sensor_fileops = {
	.owner = THIS_MODULE,
	.open = sensor_open,
	.unlocked_ioctl = sensor_ioctl,
	.release = mi5140_sensor_release,
};

static struct miscdevice sensor_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = MI5140_SENSOR_NAME,
	.fops = &sensor_fileops,
};
int __init mi5140_sensor_yuv_late_init(void);
static int sensor_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	int err=0;

	pr_info("yuv %s, compiled at %s %s\n",__func__,__DATE__,__TIME__);

	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);

	if (!info) {
		pr_err("yuv_sensor : Unable to allocate memory!\n");
		return -ENOMEM;
	}
#ifndef _CAM_SENSOR_DETECT_
  err = misc_register(&sensor_device);
	if (err) {
		pr_err("yuv_sensor : Unable to register misc device!\n");
		kfree(info);
		return err;
	}
#endif
	info->pdata = client->dev.platform_data;
	info->i2c_client = client;
#ifdef _CAM_SENSOR_DETECT_
	info->dev = client->dev;
#endif

	i2c_set_clientdata(client, info);
	mi5140_sensor_yuv_late_init();
	return 0;
}

static int sensor_remove(struct i2c_client *client)
{
	struct sensor_info *info;

	pr_info("yuv %s\n",__func__);
	info = i2c_get_clientdata(client);
	misc_deregister(&sensor_device);
	kfree(info);
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{ MI5140_SENSOR_NAME, 0 },
	{ },
};

MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_i2c_driver = {
	.driver = {
		.name = MI5140_SENSOR_NAME,
		.owner = THIS_MODULE,
	},
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};

#ifdef _CAM_SENSOR_DETECT_
int tegra_camera_set_caminfo(int num, int on);
int tegra_camera_mclk_on_off(int on);


int __init mi5140_sensor_yuv_late_init(void)
{
  int ret=-EINVAL;
  u16 temp;

  if (!info || !info->pdata || !info->pdata->power_on)
    goto fail;

  info->pdata->power_on();

  msleep(10);

  tegra_camera_mclk_on_off(1);

  ret = sensor_read_reg(info->i2c_client, 0x3000, &temp);
  if (ret)
  {
    ret = sensor_read_reg(info->i2c_client, 0x3000, &temp);
  }

  if (ret)
  {	//detect ov5640 here!
    printk("failed to detect mi5140 sesnor!\n");
    // override i2c_client's slave address
    info->i2c_client->addr=0x3c;
    ret = sensor_read_reg(info->i2c_client, 0x300A, &temp);
    if (ret == 0)
    {
      printk("OV5640 detected,  ID as 0x%x",temp);
      tegra_camera_set_caminfo(0,1);
    }
    else
    {
        printk("default using OV5640\n");
        tegra_camera_set_caminfo(0,1);
    }
    info->i2c_client->addr=0x3d;
  }
  else
  {
    printk("read ID as 0x%x",temp);
    misc_register(&sensor_device);
    tegra_camera_set_caminfo(2,1);
  }

  ret = 0;
  fail:

  info->pdata->power_off();
  tegra_camera_mclk_on_off(0);

  return ret;
}

//late_initcall(mi5140_sensor_yuv_late_init);
#endif
static int __init sensor_init(void)
{
	pr_info("yuv %s\n",__func__);
	return i2c_add_driver(&sensor_i2c_driver);
}

static void __exit sensor_exit(void)
{
	pr_info("yuv %s\n",__func__);
	i2c_del_driver(&sensor_i2c_driver);
}

module_init(sensor_init);
module_exit(sensor_exit);

